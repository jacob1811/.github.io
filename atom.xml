<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芸豆blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://jacob1811.github.io/blog/"/>
  <updated>2019-12-31T12:06:41.578Z</updated>
  <id>https://jacob1811.github.io/blog/</id>
  
  <author>
    <name>jacob</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue项目最佳实践</title>
    <link href="https://jacob1811.github.io/blog/2019/12/31/vue%E9%A1%B9%E7%9B%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://jacob1811.github.io/blog/2019/12/31/vue项目最佳实践/</id>
    <published>2019-12-31T11:33:19.000Z</published>
    <updated>2019-12-31T12:06:41.578Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d548b83f265da03ab42471d" target="_blank" rel="noopener">原文</a></p><p>1、v-if 和 v-show<br>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。<br>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><p>2、 computed 和 watch<br>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；<br>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><blockquote><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p></blockquote><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><p>3、 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</p><p>（1）v-for 遍历必须为 item 添加 key<br>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。<br>（2）v-for 遍历避免同时使用 v-if<br>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"user in activeUsers"</span></span><br><span class="line">    :key=<span class="string">"user.id"</span>&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">computed: &#123;</span><br><span class="line">  activeUsers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.users.filter(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> user.isActive</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、长列表性能优化<br>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    users: &#123;&#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">async</span> created() &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> axios.get(<span class="string">"/api/users"</span>);</span><br><span class="line">    <span class="keyword">this</span>.users = <span class="built_in">Object</span>.freeze(users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5、事件的销毁<br>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、图片资源懒加载<br>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：</p><p>（1）安装插件</p><blockquote><p>npm install vue-lazyload –save-dev</p></blockquote><p>（2）在入口文件 man.js 中引入并使用</p><blockquote><p>import VueLazyload from ‘vue-lazyload’</p></blockquote><p>然后再 vue 中直接使用</p><blockquote><p>Vue.use(VueLazyload)</p></blockquote><p>或者添加自定义选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">preLoad: <span class="number">1.3</span>,</span><br><span class="line">error: <span class="string">'dist/error.png'</span>,</span><br><span class="line">loading: <span class="string">'dist/loading.gif'</span>,</span><br><span class="line">attempt: <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p><blockquote><img v-lazy="/static/img/1.png">以上为 vue-lazyload 插件的简单使用更多参数可以查看 [vue-lazyload](https://github.com/hilongjw/vue-lazyload)。</blockquote><p>7、路由懒加载<br>Vue  是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>8、第三方插件的按需引入<br>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：<br>(1)首先，安装 babel-plugin-component ：</p><blockquote><p>npm install babel-plugin-component -D<br>(2)然后，将 .babelrc 修改为：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [[<span class="string">"es2015"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3）在 main.js 中引入部分组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"></span><br><span class="line"> Vue.use(Button)</span><br><span class="line"> Vue.use(Select)</span><br></pre></td></tr></table></figure><p>9、优化无限列表性能<br>如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 你可以参考以下开源项目 <a href="https://github.com/tangbc/vue-virtual-scroll-list" target="_blank" rel="noopener">vue-virtual-scroll-list</a> 和 <a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a>  来优化这种无限列表的场景的。</p><p>10、服务端渲染 SSR or 预渲染</p><p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。</p><p>（1）服务端渲染的优点：</p><p>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p><p>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</p><p>（2）服务端渲染的缺点：</p><p>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</p><p>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p><p>如果你的 Vue 项目只需改善少数营销页面（例如  /， /about， /contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 <a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a> 就可以轻松地添加预渲染 。</p><h3 id="Webpack-层面的优化"><a href="#Webpack-层面的优化" class="headerlink" title="Webpack 层面的优化"></a>Webpack 层面的优化</h3><p>2.1Webpack 对图片进行压缩<br>在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片：<br>（1）首先，安装 image-webpack-loader  ：</p><blockquote><p>npm install image-webpack-loader –save-dev<br>（2）然后，在 webpack.base.conf.js  中进行配置：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: <span class="number">10000</span>,</span><br><span class="line">      name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2、减少 ES6 转为 ES5 的冗余代码<br>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p><blockquote><p>class HelloWebpack extends Component{…}<br>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babel-runtime/helpers/createClass  <span class="comment">// 用于实现 class 语法</span></span><br><span class="line">babel-runtime/helpers/inherits  <span class="comment">// 用于实现 extends 语法</span></span><br></pre></td></tr></table></figure><p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。<a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">babel-plugin-transform-runtime</a> 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p><p>1）首先，安装 babel-plugin-transform-runtime ：</p><blockquote><p>npm install babel-plugin-transform-runtime –save-dev<br>2）然后，修改 .babelrc 配置文件为：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-runtime"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>2.3、提取公共代码<br>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：<br>相同的资源被重复加载，浪费用户的流量和服务器的成本。<br>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。<br>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'vendor'</span>,</span><br><span class="line">  minChunks: <span class="function"><span class="keyword">function</span>(<span class="params">module, count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">      <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">        path.join(__dirname, <span class="string">'../node_modules'</span>)</span><br><span class="line">      ) === <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 抽取出代码模块的映射关系</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'manifest'</span>,</span><br><span class="line">  chunks: [<span class="string">'vendor'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://webpack.docschina.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">CommonsChunkPlugin</a></p><p>2.4 模板预编译<br>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。<br>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。<br>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 <a href="https://github.com/ktsn/vue-template-loader" target="_blank" rel="noopener">vue-template-loader</a>，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p><p>2.5 提取组件的 CSS<br>当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。</p><p>查阅这个构建工具各自的文档来了解更多：</p><p><a href="https://vue-loader-v14.vuejs.org/zh-cn/configurations/extract-css.html" target="_blank" rel="noopener">webpack + vue-loader</a></p><p>2.6优化 SourceMap<br>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。</p><p>SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gag5mod315j310x0u0q8x.jpg" alt=""><br>开发环境推荐： cheap-module-eval-source-map</p><p>生产环境推荐： cheap-module-source-map<br>原因如下：</p><p>cheap： 源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</p><p>module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</p><p>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；</p><p>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</p><p>2.8、构建结果输出分析<br>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。<br>我们在项目中 webpack.prod.conf.js 进行配置：<br>if (config.build.bundleAnalyzerReport) {<br>  var BundleAnalyzerPlugin =   require(‘webpack-bundle-analyzer’).BundleAnalyzerPlugin;<br>  webpackConfig.plugins.push(new BundleAnalyzerPlugin());<br>}<br>复制代码执行  $ npm run build –report  后生成分析报告如下</p><p>2.8、Vue 项目的编译优化<br>如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。具体如何进行 Vue 项目的 Webpack 构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》</p><p><a href="https://juejin.im/post/5c1fa158f265da613c09cb36" target="_blank" rel="noopener"> Vue 项目 Webpack 优化实践</a></p><p>3、基础的 Web 技术优化<br>3.1开启 gzip 压缩<br>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右<br>以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下：</p><p>安装：</p><blockquote><p>npm install compression –save</p></blockquote><p>添加代码逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compression = <span class="built_in">require</span>(<span class="string">'compression'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(compression())</span><br></pre></td></tr></table></figure><p>重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功 ：<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gag5qd51i2j30o20kugnv.jpg" alt=""></p><p>3.2浏览器缓存<br>为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章<a href="https://juejin.im/post/5c93ba526fb9a070ca103898" target="_blank" rel="noopener">深入理解HTTP缓存机制及原理</a>，这里不再赘述。</p><p>3.3、CDN 的使用<br>浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p><p>3.4、使用 Chrome Performance 查找性能瓶颈<br>Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。</p><p>打开 Chrome 开发者工具，切换到 Performance 面板<br>点击 Record 开始录制<br>刷新页面或展开某个节点<br>点击 Stop 停止录制</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gag5rt6mifj31080t242u.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d548b83f265da03ab42471d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、v-if 和 v-show&lt;br&gt;v-if 是 真正 的条件渲染
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>批改端性能优化实践</title>
    <link href="https://jacob1811.github.io/blog/2019/12/31/%E6%89%B9%E6%94%B9%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>https://jacob1811.github.io/blog/2019/12/31/批改端性能优化实践/</id>
    <published>2019-12-31T07:24:16.000Z</published>
    <updated>2019-12-31T12:06:37.049Z</updated>
    
    <content type="html"><![CDATA[<p>1、post_</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">         </span><br><span class="line"></span><br><span class="line">// 警告</span><br><span class="line"><span class="selector-tag">Second</span> <span class="selector-tag">Autoprefixer</span> <span class="selector-tag">control</span> <span class="selector-tag">comment</span> <span class="selector-tag">was</span> <span class="selector-tag">ignored</span>. <span class="selector-tag">Autoprefixer</span> <span class="selector-tag">applies</span> <span class="selector-tag">control</span> <span class="selector-tag">comment</span> <span class="selector-tag">to</span> <span class="selector-tag">whole</span> <span class="selector-tag">block</span>, <span class="selector-tag">not</span> <span class="selector-tag">to</span> <span class="selector-tag">next</span> <span class="selector-tag">rules</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! autoprefixer: off */</span></span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line"><span class="comment">/* autoprefixer: on */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // css-loader 警告</span><br><span class="line"><span class="comment">/*! autoprefixer: ignore next */</span></span><br><span class="line"> <span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br></pre></td></tr></table></figure><p>2、<a href="https://blog.csdn.net/u013250071/article/details/81000777" target="_blank" rel="noopener">jenkins时间设置</a><br>3、<a href="https://www.jianshu.com/p/3b0a60248f7c" target="_blank" rel="noopener">vue-loader 15.X后无法加载组件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、post_&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>react最佳实践</title>
    <link href="https://jacob1811.github.io/blog/2019/12/08/react%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://jacob1811.github.io/blog/2019/12/08/react最佳实践/</id>
    <published>2019-12-08T13:48:39.000Z</published>
    <updated>2019-12-08T23:53:55.981Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、-尽量使用函数式组件（Function-Component）"><a href="#1、-尽量使用函数式组件（Function-Component）" class="headerlink" title="1、 尽量使用函数式组件（Function Component）"></a>1、 尽量使用函数式组件（Function Component）</h4><blockquote><p>前提：组件不需要维护state和生命周期</p></blockquote><p>优点：</p><ul><li>代码更简洁，一看就知道是纯展示型的，没有复杂的业务逻辑</li><li>更好的复用性。只要传入相同结构的 props，就能展示相同的界面，不需要考虑副作用。</li><li>更小的打包体积，更高的执行效率</li></ul><p>典型的一段函数是组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MenuItem</span>(<span class="params">&#123;menuId, menuText, onClick, activeId&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div</span><br><span class="line">            menuId=&#123;menuId&#125;</span><br><span class="line">            className=&#123;<span class="string">`<span class="subst">$&#123;style&#125;</span> <span class="subst">$&#123;activeId === menuId ? active : <span class="string">''</span>&#125;</span>`</span>&#125;</span><br><span class="line">            onClick=&#123;onItemClick&#125;</span><br><span class="line">        &gt;</span><br><span class="line">            &#123;menuText&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="2、-使用-PureComponent-替换-Component"><a href="#2、-使用-PureComponent-替换-Component" class="headerlink" title="2、 使用 PureComponent 替换 Component"></a>2、 使用 PureComponent 替换 Component</h4><p>如果组件需要维护 state 或使用生命周期方法，则优先使用 PureComponent，而不是 Component。Component 的默认行为是不论 state 和 props 是否有变化，都触发 render。而 PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render Child'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.obj.num&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  state = &#123;</span></span><br><span class="line"><span class="regexp">    obj: &#123; num: 1 &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  onClick = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;obj&#125; = this.state;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;obj&#125;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('render Parent');</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div className="App" &gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.onClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">          点我</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">        &lt;Child obj=&#123;<span class="keyword">this</span>.state.obj&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>点击按钮后，Parent 和 Child 的 render 都会触发。<br>如果将 Child 改为 PureComponent，则 Child 的 render 不会触发，因为 props 还是同一个对象。<br>如果将 Parent 也改为 PureComponent，则 Parent 的 render 也不会触发了，因为 state 还是同一个对象。</p><h4 id="3、-遵循单一职责原则，使用-HOC-装饰器-Render-Props-增加职责"><a href="#3、-遵循单一职责原则，使用-HOC-装饰器-Render-Props-增加职责" class="headerlink" title="3、 遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责"></a>3、 遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责</h4><p>比如一个公用的组件，数据来源可能是父组件传过来，又或者是自己主动通过网络请求获取数据。这时候可以先定义一个纯展示型的 Function Component，然后再定义一个高阶组件去获取数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> fetchData();</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;data&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;/</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4、组合优于继承"><a href="#4、组合优于继承" class="headerlink" title="4、组合优于继承"></a>4、组合优于继承</h4><p>继承优势：复用性好 （将复用的业务逻辑和 UI 模版都在父类定义好，子类只需要传入一些参数，然后再覆盖父类的几个方法就好（render的时候会用到））<br>继承缺点：代码难以维护（很重要）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.fetchData(<span class="keyword">this</span>.url);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fetchData(url) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    calcData()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">this</span>.calcData();</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;data&#125;&lt;<span class="regexp">/data&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Child extends Parent &#123;</span></span><br><span class="line"><span class="regexp">    constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">        super(props);</span></span><br><span class="line"><span class="regexp">        this.url = 'http:/</span><span class="regexp">/api';</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    calcData() &#123;</span></span><br><span class="line"><span class="regexp">        ...</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这样的写法从语言的特性和功能实现来说，没有任何问题，最大的问题是不符合 React 的组件编写习惯。父类或者子类肯定有一方是不需要实现 render 方法的，而一般我们看代码都会优先找 render 方法，找不到就慌了。另外就是搞不清楚哪些方法是父类实现的，哪些方法是子类实现的，如果让其他人来维护这份代码，会比较吃力。<br>继承会让代码难以溯源，定位问题也比较麻烦。所有通过继承实现的组件都可以改写为组合的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.fetchData(<span class="keyword">this</span>.props.url);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fetchData(url) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">this</span>.props.calcData(<span class="keyword">this</span>.state);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;data&#125;&lt;<span class="regexp">/data&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Child extends PureComponent &#123;</span></span><br><span class="line"><span class="regexp">    calcData(state) &#123;</span></span><br><span class="line"><span class="regexp">        ...</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        &lt;Parent url="http:/</span><span class="regexp">/api" calcData=&#123;this.calcData&#125;/</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式组合式(多入口)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.message&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Dialog</span></span><br><span class="line"><span class="regexp">      title="Welcome"</span></span><br><span class="line"><span class="regexp">      message="Thank you for visiting our spacecraft!" /</span>&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件组合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.message&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class SignUpDialog extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.handleChange = this.handleChange.bind(this);</span></span><br><span class="line"><span class="regexp">    this.handleSignUp = this.handleSignUp.bind(this);</span></span><br><span class="line"><span class="regexp">    this.state = &#123;login: ''&#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Dialog title="Mars Exploration Program"</span></span><br><span class="line"><span class="regexp">              message="How should we refer to you?"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;this.state.login&#125;</span></span><br><span class="line"><span class="regexp">               onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleSignUp&#125;&gt;</span><br><span class="line">          Sign Me Up!</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Dialog&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">login</span>: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSignUp() &#123;</span><br><span class="line">    alert(<span class="string">`Welcome aboard, <span class="subst">$&#123;<span class="keyword">this</span>.state.login&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、如果-props-的数据不会改变，就不需要在-state-或者组件实例属性里拷贝一份"><a href="#5、如果-props-的数据不会改变，就不需要在-state-或者组件实例属性里拷贝一份" class="headerlink" title="5、如果 props 的数据不会改变，就不需要在 state 或者组件实例属性里拷贝一份"></a>5、如果 props 的数据不会改变，就不需要在 state 或者组件实例属性里拷贝一份</h4><p>常见代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: nextProps.num&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.state.num&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>num 在组件中不会做任何的改变，这种情况下直接使用 this.props.num 就可以了。</p><h4 id="6、避免在-render-里面动态创建对象-方法，否则会导致子组件每次都-render"><a href="#6、避免在-render-里面动态创建对象-方法，否则会导致子组件每次都-render" class="headerlink" title="6、避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render"></a>6、避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;<span class="attr">num</span>: <span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Child obj=&#123;obj&#125; onClick=&#123;()=&gt;&#123;...&#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使 Child 是 PureComponent，由于 obj 和 onClick 每次 render 都是新的对象，Child 也会跟着 render</p><h4 id="7、避免在-JSX-中写复杂的三元表达式，应通过封装函数或组件实现"><a href="#7、避免在-JSX-中写复杂的三元表达式，应通过封装函数或组件实现" class="headerlink" title="7、避免在 JSX 中写复杂的三元表达式，应通过封装函数或组件实现"></a>7、避免在 JSX 中写复杂的三元表达式，应通过封装函数或组件实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                a &gt; <span class="number">0</span> ? a &lt; <span class="number">9</span> ? ... : ... : ...</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>改写成函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.f()</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="8、多使用解构，如-Function-Component-的-props"><a href="#8、多使用解构，如-Function-Component-的-props" class="headerlink" title="8、多使用解构，如 Function Component 的 props"></a>8、多使用解构，如 Function Component 的 props</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MenuItem = (&#123;</span><br><span class="line">    menuId, menuText, onClick, activeId,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        ...</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="9、定义组件时，定义-PropTypes-和-defaultProps-ts里通过interface实现"><a href="#9、定义组件时，定义-PropTypes-和-defaultProps-ts里通过interface实现" class="headerlink" title="9、定义组件时，定义 PropTypes 和 defaultProps (ts里通过interface实现)"></a>9、定义组件时，定义 PropTypes 和 defaultProps (ts里通过interface实现)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CategorySelector</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CategorySelector.propTypes = &#123;</span><br><span class="line">    type: PropTypes.string,</span><br><span class="line">    catList: PropTypes.array.isRequired,</span><br><span class="line">    <span class="keyword">default</span>: PropTypes.bool,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CategorySelector.defaultProps = &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">false</span>,</span><br><span class="line">    type: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>propType校验定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">  <span class="comment">// 你可以声明一个 prop 是一个特定的 JS 原始类型。 </span></span><br><span class="line">  <span class="comment">// 默认情况下，这些都是可选的。</span></span><br><span class="line">  optionalArray: PropTypes.array,</span><br><span class="line">  optionalBool: PropTypes.bool,</span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  optionalNumber: PropTypes.number,</span><br><span class="line">  optionalObject: PropTypes.object,</span><br><span class="line">  optionalString: PropTypes.string,</span><br><span class="line">  optionalSymbol: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何东西都可以被渲染:numbers, strings, elements,或者是包含这些类型的数组(或者是片段)。</span></span><br><span class="line">  optionalNode: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素。</span></span><br><span class="line">  optionalElement: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以声明一个 prop 是类的一个实例。 </span></span><br><span class="line">  <span class="comment">// 使用 JS 的 instanceof 运算符。</span></span><br><span class="line">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以声明 prop 是特定的值，类似于枚举</span></span><br><span class="line">  optionalEnum: PropTypes.oneOf([<span class="string">'News'</span>, <span class="string">'Photos'</span>]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个对象可以是多种类型其中之一</span></span><br><span class="line">  optionalUnion: PropTypes.oneOfType([</span><br><span class="line">    PropTypes.string,</span><br><span class="line">    PropTypes.number,</span><br><span class="line">    PropTypes.instanceOf(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个某种类型的数组</span></span><br><span class="line">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性值为某种类型的对象</span></span><br><span class="line">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个特定形式的对象</span></span><br><span class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以使用 `isRequired' 链接上述任何一个，以确保在没有提供 prop 的情况下显示警告。</span></span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何数据类型的值</span></span><br><span class="line">  requiredAny: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以声明自定义的验证器。如果验证失败返回 Error 对象。不要使用 `console.warn` 或者 throw ，</span></span><br><span class="line">  <span class="comment">// 因为这不会在 `oneOfType` 类型的验证器中起作用。</span></span><br><span class="line">  customProp: <span class="function"><span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(props[propName])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Invalid prop `'</span> + propName + <span class="string">'` supplied to'</span> +</span><br><span class="line">        <span class="string">' `'</span> + componentName + <span class="string">'`. Validation failed.'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 也可以声明`arrayOf`和`objectOf`类型的验证器，如果验证失败需要返回Error对象。</span></span><br><span class="line">  <span class="comment">// 会在数组或者对象的每一个元素上调用验证器。验证器的前两个参数分别是数组或者对象本身，</span></span><br><span class="line">  <span class="comment">// 以及当前元素的键值。</span></span><br><span class="line">  customArrayProp: PropTypes.arrayOf(<span class="function"><span class="keyword">function</span>(<span class="params">propValue, key, componentName, location, propFullName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(propValue[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Invalid prop `'</span> + propFullName + <span class="string">'` supplied to'</span> +</span><br><span class="line">        <span class="string">' `'</span> + componentName + <span class="string">'`. Validation failed.'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="10、避免使用无谓的标签和样式"><a href="#10、避免使用无谓的标签和样式" class="headerlink" title="10、避免使用无谓的标签和样式"></a>10、避免使用无谓的标签和样式</h4><p>下面这种情况一般外层的div是多余的，可以将样式直接定义在组件内，或者将定制的样式作为参数传入。例外：当ServiceItem需要在多个地方使用，而且要叠加很多不一样的样式，原写法会方便些。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">&lt;div key=&#123;item.uuid&#125; className=&#123;scss.serviceItemContainer&#125;&gt;</span><br><span class="line">    &lt;ServiceItem item=&#123;item&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ good</span></span><br><span class="line"><span class="regexp">&lt;ServiceItem key=&#123;item.uuid&#125; item=&#123;item&#125; className=&#123;customStyle&#125; /</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、-尽量使用函数式组件（Function-Component）&quot;&gt;&lt;a href=&quot;#1、-尽量使用函数式组件（Function-Component）&quot; class=&quot;headerlink&quot; title=&quot;1、 尽量使用函数式组件（Function Compon
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>react黑科技</title>
    <link href="https://jacob1811.github.io/blog/2019/11/30/react%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://jacob1811.github.io/blog/2019/11/30/react常用技巧/</id>
    <published>2019-11-30T14:22:34.000Z</published>
    <updated>2019-12-03T04:42:29.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><ol><li><p>prop</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">"antd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">EightteenChildOne</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//propTypes校验</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123; </span><br><span class="line">    name: PropTypes.string</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过触发方法子传父</span></span><br><span class="line">    <span class="keyword">this</span>.props.eightteenChildOneToFather(<span class="string">"这是 props 改变父元素的值"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;这是通过 props 传入的值&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button type="primary" onClick=&#123;this.click&#125;&gt;</span></span><br><span class="line"><span class="regexp">          点击改变父元素值</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line">&lt;EightteenChildOne name=&#123;<span class="string">'props 传入的 name 值'</span>&#125; </span><br><span class="line">  eightteenChildOneToFather=&#123;(mode)=&gt;<span class="keyword">this</span>.eightteenChildOneToFather(mode)&#125;&gt;</span><br><span class="line">&lt;<span class="regexp">/EightteenChildOne&gt; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 或者</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ bind</span></span><br><span class="line"><span class="regexp">&lt;EightteenChildOne name=&#123;'props 传入的 name 值'&#125; </span></span><br><span class="line"><span class="regexp">  eightteenChildOneToFather=&#123;this.eightteenChildOneToFather.bind(this)&#125;&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>EightteenChildOne&gt;</span><br></pre></td></tr></table></figure></li><li><p>Prop多个 值<br>一般写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;dataOne,dataTwo,dataThree&#125; = <span class="keyword">this</span>.state</span><br><span class="line">&lt;Com dataOne=&#123;dataOne&#125; dataTwo=&#123;dataTwo&#125; dataThree=&#123;dataThree&#125;&gt;</span><br></pre></td></tr></table></figure><p>黑科技写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Com &#123;...&#123;dataOne,dataTwo,dataThree&#125;&#125;&gt;</span><br></pre></td></tr></table></figure></li><li><p>常见子组件修改父组件状态<br>原理:子组件里面利用 props 获取父组件方法直接调用,从而改变父组件的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">state = &#123;</span><br><span class="line">  count: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">changeParentState = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.changeParentState(&#123; <span class="attr">count</span>: <span class="number">2</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Provider,Consumer和Context<br>react16.x 之前：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//根组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;ContextComponent&#125; <span class="keyword">from</span> <span class="string">'../components'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      color:<span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    text: PropTypes.string,</span><br><span class="line">    handelChange:PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;color&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      color: color,</span><br><span class="line">      text: <span class="string">"item text"</span>,</span><br><span class="line">      handelChange:<span class="keyword">this</span>.handelChange</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handelChange=<span class="function">(<span class="params">color</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      color</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'color----'</span>,color);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;ContextComponent&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ContextComponent&gt;&lt;/</span>ContextComponent&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/中间组件</span></span><br><span class="line"><span class="regexp">import React from 'react'</span></span><br><span class="line"><span class="regexp">import ChildPropsData from './</span>ChildPropsData<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default function index() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      儿子</span></span><br><span class="line"><span class="string">      &lt;ChildPropsData&gt;&lt;/ChildPropsData&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//孙组件(接收组件)-class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import React, &#123; Component &#125; from '</span>react<span class="string">'</span></span><br><span class="line"><span class="string">import PropTypes from '</span>prop-types<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default class childPropsData extends Component &#123;</span></span><br><span class="line"><span class="string">  static contextTypes = &#123;    // 内部 static定义</span></span><br><span class="line"><span class="string">    color: PropTypes.string,</span></span><br><span class="line"><span class="string">    text: PropTypes.string</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    console.log(this.context);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">      &#123;JSON.stringify(this.context)&#125;</span></span><br><span class="line"><span class="string">      孙子</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//孙组件(接收组件)-function</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import React from '</span>react<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default function childPropsData(props,context) &#123;  // context需要传入</span></span><br><span class="line"><span class="string">      return (</span></span><br><span class="line"><span class="string">          &lt;div&gt;</span></span><br><span class="line"><span class="string">            &#123;JSON.stringify(context)&#125;</span></span><br><span class="line"><span class="string">            孙子</span></span><br><span class="line"><span class="string">            &lt;button onClick=&#123;()=&gt;context.handelChange('</span>yellow<span class="string">')&#125;&gt;切换颜色&lt;/button&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">childPropsData.contextTypes = &#123; //  // 外部 &#123;&#125;.X 定义</span></span><br><span class="line"><span class="string">  color: PropTypes.string,</span></span><br><span class="line"><span class="string">  text: PropTypes.string,</span></span><br><span class="line"><span class="string">  handelChange:PropTypes.func,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>显然很麻烦，幸运的是react优化了这一操作：</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;组件通讯&quot;&gt;&lt;a href=&quot;#组件通讯&quot; class=&quot;headerlink&quot; title=&quot;组件通讯&quot;&gt;&lt;/a&gt;组件通讯&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;prop&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>getter-setter</title>
    <link href="https://jacob1811.github.io/blog/2019/11/27/getter-setter/"/>
    <id>https://jacob1811.github.io/blog/2019/11/27/getter-setter/</id>
    <published>2019-11-27T09:39:39.000Z</published>
    <updated>2019-11-27T09:47:15.268Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript对象的属性是由名字、值和一组特性（可写、可枚举、可配置等）构成的。在ECMAScript 5中，属性值可以用一个或两个方法代替，这两个方法就是getter和setter。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">get</span> b()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObj.a);<span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.b);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>上面的代码中，属性a称为“<code>数据属性</code>”，它只有一个简单的值；像属性b这种用getter和setter方法定义的属性称为“<code>存取器属性</code>”。</p><p>存取器属性定义为一个或两个与<code>属性同名的函数</code>，这个函数定义没有使用function关键字，而是使用get或set，也没有使用冒号将属性名和函数体分开，但函数体的结束和下一个方法之间有逗号隔开。</p><p>当程序查询存取器的属性值时，JavaScript代用getter方法（无参数），这个方法的返回值就是该属性存取表达式的值。当程序设置一个存取器属性值时，JavaScript调用setter方法，将赋值表达式右侧的值当作参数传入setter。从某种意义上来说，这个方法负责设置属性值，可以忽略该方法的返回值。</p><p>当一个属性被定义为存取器属性时，JavaScript会忽略它的value和writable特性，取而代之的是set和get（还有configurable和enumerable）特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="keyword">get</span> a()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObj.a);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>如上面代码所示，由于我们只定义了属性a的getter，所以对a进行设置（即赋值）时set会忽略赋值操作，不会抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="keyword">get</span> a()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> a(val)&#123;</span><br><span class="line">        <span class="keyword">this</span>._a_ = val;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObj.a);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>正确的写法如上所示。getter和setter方法中的this都指向myObj对象。这里我们把赋值操作中的3存储到另一个中间变量 <em>a</em> 中。名称 <em>a</em> 只是一种惯例，并没有其它任何特殊行为，它只是一个普通的属性。把它换成其它任意合法名称如 <em>b</em> 都行，甚至可以在外面将它打印出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="keyword">get</span> a()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._b_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> a(val)&#123;</span><br><span class="line">        <span class="keyword">this</span>._b_ = val;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObj.a);<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj._b_);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>另外，存取器属性也是可以继承的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="keyword">get</span> a()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._b_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> a(val)&#123;</span><br><span class="line">        <span class="keyword">this</span>._b_ = val;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherObj = <span class="built_in">Object</span>.create(myObj);</span><br><span class="line"><span class="built_in">console</span>.log(anotherObj.a);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u012510478/article/details/54312482" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript对象的属性是由名字、值和一组特性（可写、可枚举、可配置等）构成的。在ECMAScript 5中，属性值可以用一个或两个方法代替，这两个方法就是getter和setter。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>es6的Class</title>
    <link href="https://jacob1811.github.io/blog/2019/11/27/es6%E7%9A%84Class/"/>
    <id>https://jacob1811.github.io/blog/2019/11/27/es6的Class/</id>
    <published>2019-11-27T09:16:23.000Z</published>
    <updated>2019-11-27T09:59:54.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>ECMAScript中没有类的概念，我们的实例是基于原型由构造函数生成具有动态属性和方法的对象。不过为了与国际接轨，描述的更为简便和高大上，依然会使用‘类’这一词。所以JS的类等同于构造函数。ES6的<code>class</code>只是个语法糖，其定义生成的对象依然构造函数。不过为了与构造函数模式区分开，我们称其为类模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---使用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'New someone.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'a'</span>; &#125;; <span class="comment">// 静态方法</span></span><br><span class="line"></span><br><span class="line">C.prototype.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125;; <span class="comment">// 原型方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---使用class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> a() &#123; <span class="keyword">return</span> <span class="string">'a'</span>; &#125; <span class="comment">// 静态方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>() &#123; <span class="built_in">console</span>.log(<span class="string">'New someone.'</span>); &#125; <span class="comment">// 构造方法</span></span><br><span class="line">  </span><br><span class="line">  b() &#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125; <span class="comment">// 原型方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="与变量对比"><a href="#与变量对比" class="headerlink" title="与变量对比"></a>与变量对比</h4><ol><li>关键字class类似定义函数的关键字function，其定义的方式有声明式和表达式（匿名式和命名式）两种。</li><li>通过声明式定义的变量的性质与function不同，更为类似let和const，不会提前解析，不存在变量提升，不与全局作用域挂钩和拥有暂时性死区3. 等。class定义生成的变量就是一个构造函数，也因此，类可以写成立即执行的模式。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---声明式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---匿名表达式</span></span><br><span class="line"><span class="keyword">let</span> C = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---命名表达式</span></span><br><span class="line"><span class="keyword">let</span> C = <span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> <span class="title">FF</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---本质是个函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> C); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(C)); <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(C.hasOwnProperty(<span class="string">'prototype'</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---不存在变量提升</span></span><br><span class="line">C; <span class="comment">// 报错，不存在C。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 存在提前解析和变量提升</span></span><br><span class="line">F; <span class="comment">// 不报错，F已被声明和赋值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---自执行模式</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> (<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="与对象对比"><a href="#与对象对比" class="headerlink" title="与对象对比"></a>与对象对比</h4><p>类内容（{}里面）的形式与对象字面量相似。</p><ol><li>不过类内容里面只能定义方法不能定义属性，es6类没有静态属性（es7才可以）</li><li>方法的形式只能是函数简写式，方法间不用也不能用逗号分隔。</li><li>方法名可以是带括号的表达式，也可以为Symbol值。</li><li>方法分为三类，构造方法（constructor方法）、原型方法（存在于构造函数的prototype属性上）和静态方法（存在于构造函数本身上）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 原型方法a</span></span><br><span class="line">  a() &#123; <span class="built_in">console</span>.log(<span class="string">'a'</span>); &#125;</span><br><span class="line">  <span class="comment">// 构造方法，每次生成实例时都会被调用并返回新实例。</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">// 静态方法b，带static关键字。</span></span><br><span class="line">  <span class="keyword">static</span> b() &#123; <span class="built_in">console</span>.log(<span class="string">'b'</span>); &#125;</span><br><span class="line">  <span class="comment">// 原型方法，带括号的表达式</span></span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'b'</span>]() &#123; <span class="built_in">console</span>.log(<span class="string">'ab'</span>); &#125;</span><br><span class="line">  <span class="comment">// 原型方法，使用Symbol值</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.for(<span class="string">'s'</span>)]() &#123; <span class="built_in">console</span>.log(<span class="string">'symbol s'</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C.b(); <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.a(); <span class="comment">// a</span></span><br><span class="line">c.ab(); <span class="comment">// ab</span></span><br><span class="line">c[<span class="built_in">Symbol</span>.for(<span class="string">'s'</span>)](); <span class="comment">// symbol s</span></span><br></pre></td></tr></table></figure><p>不能直接定义属性，并不表示类不能有原型或静态属性。解析class会形成一个构造函数，因此只需像为构造函数添加属性一样为类添加即可。更为直接也是推荐的是只使用getter函数定义只读属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---直接在C类（构造函数）上修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line">C.a = <span class="string">'a'</span>;</span><br><span class="line">C.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125;;</span><br><span class="line">C.prototype.c = <span class="string">'c'</span>;</span><br><span class="line">C.prototype.d = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'d'</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.c; <span class="comment">// c</span></span><br><span class="line">c.d(); <span class="comment">// d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---使用setter和getter</span></span><br><span class="line"><span class="comment">// 定义只能获取不能修改的原型或静态属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> a() &#123; <span class="keyword">return</span> <span class="string">'a'</span>; &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> b() &#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.a; <span class="comment">// a</span></span><br><span class="line">c.a = <span class="string">'1'</span>; <span class="comment">// 赋值没用，只有get没有set无法修改。</span></span><br></pre></td></tr></table></figure><h4 id="与构造函数对比"><a href="#与构造函数对比" class="headerlink" title="与构造函数对比"></a>与构造函数对比</h4><p>直观上，class简化了代码，使得内容更为聚合。constructor方法体等同构造函数的函数体，如果没有显式定义此方法，一个空的constructor方法会被默认添加用于返回新的实例。与ES5一样，也可以自定义返回另一个对象而不是新实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态属性和方法</span></span><br><span class="line">C.b = <span class="string">'b'</span>;</span><br><span class="line">C.c = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'c'</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型属性和方法</span></span><br><span class="line">C.prototype.d = <span class="string">'d'</span>;</span><br><span class="line">C.prototype.e = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'e'</span>; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(C.prototype, <span class="string">'f'</span>, &#123; <span class="comment">// 只读属性</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'f'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> c() &#123; <span class="keyword">return</span> <span class="string">'c'</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(a) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  e() &#123; <span class="keyword">return</span> <span class="string">'e'</span>; &#125;</span><br><span class="line">  <span class="keyword">get</span> f() &#123; <span class="keyword">return</span> <span class="string">'f'</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C.b = <span class="string">'b'</span>;</span><br><span class="line">C.prototype.d = <span class="string">'d'</span>;</span><br></pre></td></tr></table></figure><p>类虽然是个函数，但只能通过new生成实例而不能直接调用。类内部所定义的全部方法是不可枚举的，在构造函数本身和prototype上添加的属性和方法是可枚举的。类内部定义的方法默认是严格模式，无需显式声明。以上三点增加了类的严谨性，比较遗憾的是，依然还没有直接定义私有属性和方法的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---能否直接调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line">C(); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">C(); <span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---是否可枚举</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> a() &#123;&#125; <span class="comment">// 不可枚举</span></span><br><span class="line">  b() &#123;&#125; <span class="comment">// 不可枚举</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C.c = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 可枚举</span></span><br><span class="line">C.prototype.d = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 可枚举</span></span><br><span class="line"></span><br><span class="line">isEnumerable(C, [<span class="string">'a'</span>, <span class="string">'c'</span>]); <span class="comment">// a false, c true</span></span><br><span class="line">isEnumerable(C.prototype, [<span class="string">'b'</span>, <span class="string">'d'</span>]); <span class="comment">// b false, d true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEnumerable</span>(<span class="params">target, keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.getOwnPropertyDescriptors(target);</span><br><span class="line">  keys.forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k, obj[k].enumerable);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---是否为严格模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="keyword">let</span> is = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      n = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      is = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(is ? <span class="string">'true'</span> : <span class="string">'false'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C.prototype.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> is = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    is = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(is ? <span class="string">'true'</span> : <span class="string">'false'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.a(); <span class="comment">// true，是严格模式。</span></span><br><span class="line">c.b(); <span class="comment">// false，不是严格模式。</span></span><br></pre></td></tr></table></figure><p>在方法前加上static关键字表示此方法为静态方法，它存在于类本身，不能被实例直接访问。静态方法中的this指向类本身。因为处于不同对象上，静态方法和原型方法可以重名。ES6新增了一个命令new.target，指代new后面的构造函数或class，该命令的使用有某些限制，具体请看下面示例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---static</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> a() &#123; <span class="built_in">console</span>.log(<span class="keyword">this</span> === C); &#125;</span><br><span class="line">  a() &#123; <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> C); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">C.a(); <span class="comment">// true</span></span><br><span class="line">c.a(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---new.target</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C.prototype.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">new</span>.target); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C(); <span class="comment">// 打印出C</span></span><br><span class="line">c.a(); <span class="comment">// 在普通方法中为undefined。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; <span class="built_in">console</span>.log(<span class="keyword">new</span>.target); &#125;</span><br><span class="line">  a() &#123; <span class="built_in">console</span>.log(<span class="keyword">new</span>.target); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C(); <span class="comment">// 打印出C</span></span><br><span class="line">c.a(); <span class="comment">// 在普通方法中为undefined。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---在函数外部使用会报错</span></span><br><span class="line"><span class="keyword">new</span>.target; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>ES5中的经典继承方法是寄生组合式继承，子类会分别继承父类实例和原型上的属性和方法。ES6中的继承本质也是如此，不过实现方式有所改变，具体如下面的代码。可以看到，原型上的继承是使用extends关键字这一更接近传统语言的形式，实例上的继承是通过调用super完成子类this塑造。表面上看，方式更为的统一和简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a) &#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">  b() &#123; <span class="built_in">console</span>.log(<span class="string">'b'</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">C1</span> </span>&#123; <span class="comment">// 继承原型数据</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'a'</span>); <span class="comment">// 继承实例数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="与构造函数对比-1"><a href="#与构造函数对比-1" class="headerlink" title="与构造函数对比"></a>与构造函数对比</h4><p>使用extends继承，不仅仅会将子类的prototype属性的原型对象（<strong>proto</strong>）设置为父类的prototype，还会将子类本身的原型对象（<strong>proto</strong>）设置为父类本身。这意味着子类不单单会继承父类的原型数据，也会继承父类本身拥有的静态属性和方法。而ES5的经典继承只会继承父类的原型数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> a() &#123; <span class="built_in">console</span>.log(<span class="string">'a'</span>); &#125;</span><br><span class="line">  <span class="keyword">static</span> b() &#123; <span class="built_in">console</span>.log(<span class="string">'b'</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价，没有构造方法会默认添加。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">C.a; <span class="comment">// a，继承了父类的静态属性。</span></span><br><span class="line">C.b(); <span class="comment">// b，继承了父类的静态方法。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(C) === C1); <span class="comment">// true，C的原型对象为C1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(C.prototype) === C1.prototype); <span class="comment">// true，C的prototype属性的原型对象为C1的prototype</span></span><br></pre></td></tr></table></figure><p>ES5中的实例继承，是先创造子类的实例对象this，再通过call或apply方法，在this上添加父类的实例属性和方法。当然也可以选择不继承父类的实例数据。而ES6不同，它的设计使得实例继承更为优秀和严谨。</p><p>在ES6的实例继承中，是先调用super方法创建父类的this（依旧指向子类）和添加父类的实例数据，再通过子类的构造函数修饰this，与ES5正好相反。ES6规定在子类的constructor方法里，在使用到this之前，必须先调用super方法得到子类的this。不调用super方法，意味着子类得不到this对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'C1'</span>, <span class="keyword">this</span> <span class="keyword">instanceof</span> C);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// 在super()之前不能使用this，否则报错。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'C'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> C(); <span class="comment">// 先打印出C1 true，再打印C。</span></span><br></pre></td></tr></table></figure><h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p>关键字super比较奇葩，在不同的环境和使用方式下，它会指代不同的东西（总的说可以指代对象或方法两种）。而且在不显式的指明是作为对象或方法使用时，比如console.log(super)，会直接报错。</p><p>作为函数时。super只能存在于子类的构造方法中，这时它指代父类构造函数。</p><p>作为对象时。super在静态方法中指代父类本身，在构造方法和原型方法中指代父类的prototype属性。不过通过super调用父类方法时，方法的this依旧指向子类。即是说，通过super调用父类的静态方法时，该方法的this指向子类本身；调用父类的原型方法时，该方法的this指向该（子类的）实例。而且通过super对某属性赋值时，在子类的原型方法里指代该实例，在子类的静态方法里指代子类本身，毕竟直接在子类中通过super修改父类是很危险的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> a() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === C);</span><br><span class="line">  &#125;</span><br><span class="line">  b() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> C);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> c() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.a); <span class="comment">// 此时super指向C1，打印出function a。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>; <span class="comment">// this等于C。</span></span><br><span class="line">    <span class="keyword">super</span>.x = <span class="number">3</span>; <span class="comment">// 此时super等于this，即C。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.x); <span class="comment">// 此时super指向C1，打印出undefined。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 值已改为3。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.a(); <span class="comment">// 打印出true，a方法的this指向C。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// 指代父类的构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.c); <span class="comment">// 此时super指向C1.prototype，打印出function c。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>; <span class="comment">// this等于新实例。</span></span><br><span class="line">    <span class="keyword">super</span>.x = <span class="number">3</span>; <span class="comment">// 此时super等于this，即实例本身。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.x); <span class="comment">// 此时super指向C1.prototype，打印出undefined。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 值已改为3。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.b(); <span class="comment">// 打印出true，b方法的this指向实例本身。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承原生构造函数"><a href="#继承原生构造函数" class="headerlink" title="继承原生构造函数"></a>继承原生构造函数</h4><p>使用构造函数模式，构建继承了原生数据结构（比如Array）的子类，有许多缺陷的。一方面由上文可知，原始继承是先创建子类this，再通过父类构造函数进行修饰，因此无法获取到父类的内部属性（隐藏属性）。另一方面，原生构造函数会直接忽略call或apply方法传入的this，导致子类根本无法获取到父类的实例属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="comment">// MyArray.prototype.constructor = MyArray;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// arr为对象，没有储存值。</span></span><br><span class="line">arr.push(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 在arr上新增了0，1和length属性。</span></span><br><span class="line">arr.map(<span class="function"><span class="params">d</span> =&gt;</span> d); <span class="comment">// 返回数组[4, 5]</span></span><br><span class="line">arr.length = <span class="number">1</span>; <span class="comment">// arr并没有更新，依旧有0，1属性，且arr[1]为5。</span></span><br></pre></td></tr></table></figure><p>创建类的过程，是先构造一个属于父类却指向子类的this（绕口），再通过父类和子类的构造函数进行修饰。因此可以规避构造函数的问题，获取到父类的实例属性和方法，包括内部属性。进而真正的创建原生数据结构的子类，从而简单的扩展原生数据类型。另外还可以通过设置Symbol.species属性，使得衍生对象为原生类而不是自定义子类的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123; <span class="comment">// 实现是如此的简单</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// arr为数组，储存有1，2，3。</span></span><br><span class="line">arr.map(<span class="function"><span class="params">d</span> =&gt;</span> d); <span class="comment">// 返回数组[1, 2, 3]</span></span><br><span class="line">arr.length = <span class="number">1</span>; <span class="comment">// arr正常更新，已包含必要的内部属性。</span></span><br></pre></td></tr></table></figure><p>需要注意的是继承Object的子类。ES6改变了Object构造函数的行为，一旦发现其不是通过new Object()这种形式调用的，构造函数会忽略传入的参数。由此导致Object子类无法正常初始化，但这不是个大问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123; <span class="keyword">return</span> <span class="built_in">Object</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyObject(&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.hasOwnPropoty(<span class="string">'id'</span>)); <span class="comment">// false，没有被正确初始化</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Class&quot;&gt;&lt;a href=&quot;#Class&quot; class=&quot;headerlink&quot; title=&quot;Class&quot;&gt;&lt;/a&gt;Class&lt;/h3&gt;&lt;p&gt;ECMAScript中没有类的概念，我们的实例是基于原型由构造函数生成具有动态属性和方法的对象。不过为了与国际接轨，
      
    
    </summary>
    
    
    
      <category term="es6" scheme="https://jacob1811.github.io/blog/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Taro-cli拆解</title>
    <link href="https://jacob1811.github.io/blog/2019/11/27/Taro-cli%E6%8B%86%E8%A7%A3/"/>
    <id>https://jacob1811.github.io/blog/2019/11/27/Taro-cli拆解/</id>
    <published>2019-11-27T07:55:41.000Z</published>
    <updated>2019-11-27T07:55:46.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="taro-cli-是怎么玩的？"><a href="#taro-cli-是怎么玩的？" class="headerlink" title="taro-cli 是怎么玩的？"></a>taro-cli 是怎么玩的？</h3><p>所有的工程化项目都一样，肯定需要CLI脚手架，Taro脚手架安装：</p><blockquote><p>npm install -g @tarojs/cli<br>(yarn npx也可以)</p></blockquote><p>安装后，恭喜你拥有了 taro 命令，主要负责项目初始化，编译，构建等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  taro-ui git:(master) ✗ taro</span><br><span class="line">👽 Taro v1<span class="number">.3</span><span class="number">.19</span></span><br><span class="line"></span><br><span class="line">Usage: taro &lt;command&gt; [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -V, --version       output the version number</span><br><span class="line">  -h, --help          output usage information</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  init [projectName]  Init a project <span class="keyword">with</span> <span class="keyword">default</span> templete</span><br><span class="line">  config &lt;cmd&gt;        Taro config</span><br><span class="line">  create              Create page <span class="keyword">for</span> project</span><br><span class="line">  build               Build a project <span class="keyword">with</span> options</span><br><span class="line">  update              Update packages <span class="keyword">of</span> taro</span><br><span class="line">  convert             Convert weapp to taro</span><br><span class="line">  info                Diagnostics Taro env info</span><br><span class="line">  doctor              Diagnose taro project</span><br><span class="line">  help [cmd]          display help <span class="keyword">for</span> [cmd]</span><br></pre></td></tr></table></figure><h3 id="包管理与发布"><a href="#包管理与发布" class="headerlink" title="包管理与发布"></a>包管理与发布</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">➜  taro-master tree -L <span class="number">2</span></span><br><span class="line">.</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── PLANS.md</span><br><span class="line">├── README.md</span><br><span class="line">├── build</span><br><span class="line">│   ├── docs-version.js</span><br><span class="line">│   └── docs.js</span><br><span class="line">├── docs</span><br><span class="line">│   ├── CONTRIBUTING.md</span><br><span class="line">│   ├── GETTING-STARTED.md</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── apis</span><br><span class="line">│   ├── <span class="keyword">async</span>-<span class="keyword">await</span>.md</span><br><span class="line">│   ├── before-dev-remind.md</span><br><span class="line">│   ├── best-practice.md</span><br><span class="line">│   ├── children.md</span><br><span class="line">│   ├── component-style.md</span><br><span class="line">│   ├── components</span><br><span class="line">│   ├── components-desc.md</span><br><span class="line">│   ├── composition.md</span><br><span class="line">│   ├── condition.md</span><br><span class="line">│   ├── config-detail.md</span><br><span class="line">│   ├── config.md</span><br><span class="line">│   ├── context.md</span><br><span class="line">│   ├── css-modules.md</span><br><span class="line">│   ├── debug.md</span><br><span class="line">│   ├── envs-debug.md</span><br><span class="line">│   ├── envs.md</span><br><span class="line">│   ├── event.md</span><br><span class="line">│   ├── functional-component.md</span><br><span class="line">│   ├── hooks.md</span><br><span class="line">│   ├── hybrid.md</span><br><span class="line">│   ├── jsx.md</span><br><span class="line">│   ├── list.md</span><br><span class="line">│   ├── mini-third-party.md</span><br><span class="line">│   ├── miniprogram-plugin.md</span><br><span class="line">│   ├── mobx.md</span><br><span class="line">│   ├── optimized-practice.md</span><br><span class="line">│   ├── project-config.md</span><br><span class="line">│   ├── props.md</span><br><span class="line">│   ├── quick-app.md</span><br><span class="line">│   ├── react-native.md</span><br><span class="line">│   ├── redux.md</span><br><span class="line">│   ├── ref.md</span><br><span class="line">│   ├── relations.md</span><br><span class="line">│   ├── render-props.md</span><br><span class="line">│   ├── report.md</span><br><span class="line">│   ├── router.md</span><br><span class="line">│   ├── size.md</span><br><span class="line">│   ├── spec-<span class="keyword">for</span>-taro.md</span><br><span class="line">│   ├── specials.md</span><br><span class="line">│   ├── state.md</span><br><span class="line">│   ├── <span class="keyword">static</span>-reference.md</span><br><span class="line">│   ├── taro-quickapp-manifest.md</span><br><span class="line">│   ├── taroize.md</span><br><span class="line">│   ├── team.md</span><br><span class="line">│   ├── template.md</span><br><span class="line">│   ├── tutorial.md</span><br><span class="line">│   ├── ui-lib.md</span><br><span class="line">│   └── wxcloud.md</span><br><span class="line">├── lerna.json      <span class="comment">// 包管理工具Lerna配置</span></span><br><span class="line">├── package.json</span><br><span class="line">├── packages</span><br><span class="line">│   ├── babel-plugin-transform-jsx-to-stylesheet</span><br><span class="line">│   ├── babel-plugin-transform-taroapi</span><br><span class="line">│   ├── css-to-react-native</span><br><span class="line">│   ├── eslint-config-taro</span><br><span class="line">│   ├── eslint-plugin-taro</span><br><span class="line">│   ├── postcss-plugin-constparse</span><br><span class="line">│   ├── postcss-pxtransform</span><br><span class="line">│   ├── postcss-unit-transform</span><br><span class="line">│   ├── stylelint-config-taro-rn</span><br><span class="line">│   ├── stylelint-taro-rn</span><br><span class="line">│   ├── taro</span><br><span class="line">│   ├── taro-alipay</span><br><span class="line">│   ├── taro-<span class="keyword">async</span>-<span class="keyword">await</span></span><br><span class="line">│   ├── taro-cli</span><br><span class="line">│   ├── taro-components</span><br><span class="line">│   ├── taro-components-qa</span><br><span class="line">│   ├── taro-components-rn</span><br><span class="line">│   ├── taro-h5</span><br><span class="line">│   ├── taro-jd</span><br><span class="line">│   ├── taro-mobx</span><br><span class="line">│   ├── taro-mobx-common</span><br><span class="line">│   ├── taro-mobx-h5</span><br><span class="line">│   ├── taro-mobx-rn</span><br><span class="line">│   ├── taro-plugin-babel</span><br><span class="line">│   ├── taro-plugin-csso</span><br><span class="line">│   ├── taro-plugin-less</span><br><span class="line">│   ├── taro-plugin-sass</span><br><span class="line">│   ├── taro-plugin-stylus</span><br><span class="line">│   ├── taro-plugin-typescript</span><br><span class="line">│   ├── taro-plugin-uglifyjs</span><br><span class="line">│   ├── taro-qq</span><br><span class="line">│   ├── taro-quickapp</span><br><span class="line">│   ├── taro-redux</span><br><span class="line">│   ├── taro-redux-h5</span><br><span class="line">│   ├── taro-redux-rn</span><br><span class="line">│   ├── taro-rn</span><br><span class="line">│   ├── taro-rn-runner</span><br><span class="line">│   ├── taro-router</span><br><span class="line">│   ├── taro-router-rn</span><br><span class="line">│   ├── taro-swan</span><br><span class="line">│   ├── taro-transformer-wx</span><br><span class="line">│   ├── taro-tt</span><br><span class="line">│   ├── taro-utils</span><br><span class="line">│   ├── taro-weapp</span><br><span class="line">│   ├── taro-webpack-runner</span><br><span class="line">│   ├── taro-<span class="keyword">with</span>-weapp</span><br><span class="line">│   └── taroize</span><br><span class="line">├── website</span><br><span class="line">│   ├── core</span><br><span class="line">│   ├── i18n</span><br><span class="line">│   ├── pages</span><br><span class="line">│   ├── sidebars.json</span><br><span class="line">│   ├── siteConfig.js</span><br><span class="line">│   ├── <span class="keyword">static</span></span><br><span class="line">│   ├── versioned_docs</span><br><span class="line">│   ├── versioned_sidebars</span><br><span class="line">│   └── versions.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>packages 目录下十几个包中，最常用的项目初始化与构建的命令行工具 taro-cli 就是其中一个。在 Taro 工程根目录运行 lerna publish 命令之后，lerna.json 里面配置好的所有的包会被发布到 npm 上去。</p><h3 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a>lerna</h3><p><a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">lerna github</a><br><a href="https://lerna.js.org/" target="_blank" rel="noopener">文档</a></p><p>安装</p><blockquote><p>npm install –global lerna</p></blockquote><p>初始化项目仓库</p><blockquote><p>git init lerna-repo &amp;&amp; cd lerna-repo</p></blockquote><p>lerna初始化</p><blockquote><p>lerna init</p></blockquote><h4 id="taro-cli-包目录结构"><a href="#taro-cli-包目录结构" class="headerlink" title="taro-cli 包目录结构"></a>taro-cli 包目录结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">➜  taro-cli tree</span><br><span class="line">.</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── __tests__</span><br><span class="line">│   ├── __snapshots__</span><br><span class="line">│   │   └── rn.test.js.snap</span><br><span class="line">│   ├── mocks</span><br><span class="line">│   │   ├── app.js</span><br><span class="line">│   │   ├── config</span><br><span class="line">│   │   │   ├── dev.js</span><br><span class="line">│   │   │   ├── index.js</span><br><span class="line">│   │   │   └── prod.js</span><br><span class="line">│   │   └── page.js</span><br><span class="line">│   └── rn.test.js</span><br><span class="line">├── bin    <span class="comment">// 命令行</span></span><br><span class="line">│   ├── taro        <span class="comment">// taro 命令</span></span><br><span class="line">│   ├── taro-build  <span class="comment">// taro build命令</span></span><br><span class="line">│   ├── taro-config   <span class="comment">// Taro config</span></span><br><span class="line">│   ├── taro-convert  <span class="comment">// Convert weapp to taro</span></span><br><span class="line">│   ├── taro-create   <span class="comment">// Create page for project</span></span><br><span class="line">│   ├── taro-doctor   <span class="comment">// Diagnose taro project</span></span><br><span class="line">│   ├── taro-info    <span class="comment">// Diagnostics Taro env info</span></span><br><span class="line">│   ├── taro-init   <span class="comment">// taro init命令  Init a project with default templete</span></span><br><span class="line">│   └── taro-update <span class="comment">// taro update命令 Update packages of taro</span></span><br><span class="line">├── global.d.ts</span><br><span class="line">├── index.js</span><br><span class="line">├── jest.config.js</span><br><span class="line">├── package.json</span><br><span class="line">├── scripts</span><br><span class="line">│   └── prepublish.js</span><br><span class="line">├── src</span><br><span class="line">│   ├── build.ts            <span class="comment">// taro build 命令调用，根据 type 类型调用不同的脚本</span></span><br><span class="line">│   ├── config</span><br><span class="line">│   │   ├── babel.ts        <span class="comment">// Babel 配置</span></span><br><span class="line">│   │   ├── babylon.ts      <span class="comment">// JavaScript 解析器 babylon 配置</span></span><br><span class="line">│   │   ├── browser_list.ts <span class="comment">// autoprefixer browsers 配置</span></span><br><span class="line">│   │   ├── index.ts        <span class="comment">// 目录名及入口文件名相关配置</span></span><br><span class="line">│   │   ├── manifest.default.json</span><br><span class="line">│   │   ├── rn-stylelint.json</span><br><span class="line">│   │   ├── tsconfig.json</span><br><span class="line">│   │   └── uglify.ts</span><br><span class="line">│   ├── convertor</span><br><span class="line">│   │   ├── helper.ts</span><br><span class="line">│   │   └── index.ts</span><br><span class="line">│   ├── create</span><br><span class="line">│   │   ├── creator.ts</span><br><span class="line">│   │   ├── fetchTemplate.ts</span><br><span class="line">│   │   ├── init.ts</span><br><span class="line">│   │   ├── page.ts</span><br><span class="line">│   │   └── project.ts         <span class="comment">// taro init 命令调用，初始化项目 </span></span><br><span class="line">│   ├── doctor</span><br><span class="line">│   │   ├── abilityXMLValidator.ts</span><br><span class="line">│   │   ├── configSchema.ts</span><br><span class="line">│   │   ├── configValidator.ts</span><br><span class="line">│   │   ├── eslintValidator.ts</span><br><span class="line">│   │   ├── index.ts</span><br><span class="line">│   │   ├── interface.ts</span><br><span class="line">│   │   ├── joi2desc.ts</span><br><span class="line">│   │   ├── packageValidator.ts</span><br><span class="line">│   │   ├── recommandValidator.ts</span><br><span class="line">│   │   └── validatorEslintrc.ts</span><br><span class="line">│   ├── h5                <span class="comment">// 构建h5 平台代码</span></span><br><span class="line">│   │   ├── constants.ts</span><br><span class="line">│   │   ├── helper.ts</span><br><span class="line">│   │   └── index.ts</span><br><span class="line">│   ├── index.ts</span><br><span class="line">│   ├── jdreact</span><br><span class="line">│   │   ├── convert_to_jdreact.ts</span><br><span class="line">│   │   ├── pkg</span><br><span class="line">│   │   ├── template</span><br><span class="line">│   │   │   ├── JDReact.version</span><br><span class="line">│   │   │   └── JDReact.web.js</span><br><span class="line">│   │   └── test.js</span><br><span class="line">│   ├── mini</span><br><span class="line">│   │   ├── astProcess.ts</span><br><span class="line">│   │   ├── compileScript.ts</span><br><span class="line">│   │   ├── compileStyle.ts</span><br><span class="line">│   │   ├── component.ts</span><br><span class="line">│   │   ├── constants.ts</span><br><span class="line">│   │   ├── entry.ts</span><br><span class="line">│   │   ├── helper.ts</span><br><span class="line">│   │   ├── index.ts</span><br><span class="line">│   │   ├── interface.ts</span><br><span class="line">│   │   ├── native.ts</span><br><span class="line">│   │   ├── page.ts</span><br><span class="line">│   │   └── watch.ts</span><br><span class="line">│   ├── plugin.ts</span><br><span class="line">│   ├── quickapp</span><br><span class="line">│   │   ├── style</span><br><span class="line">│   │   │   ├── declaration</span><br><span class="line">│   │   │   │   ├── animation</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── background</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── border</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── box</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── color</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── component</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── dimension</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── flexbox</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── font</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── index.ts</span><br><span class="line">│   │   │   │   ├── list</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── margin</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── padding</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── position</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── text</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── transform</span><br><span class="line">│   │   │   │   │   └── transform.ts</span><br><span class="line">│   │   │   │   ├── transition</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   └── visibility</span><br><span class="line">│   │   │   │       └── index.ts</span><br><span class="line">│   │   │   ├── index.ts</span><br><span class="line">│   │   │   ├── selector</span><br><span class="line">│   │   │   │   └── index.ts</span><br><span class="line">│   │   │   └── util.ts</span><br><span class="line">│   │   ├── style-rewriter.ts</span><br><span class="line">│   │   ├── template</span><br><span class="line">│   │   │   ├── constant.ts</span><br><span class="line">│   │   │   ├── node.ts</span><br><span class="line">│   │   │   ├── parser.ts</span><br><span class="line">│   │   │   ├── serialize.ts</span><br><span class="line">│   │   │   ├── tag</span><br><span class="line">│   │   │   │   ├── index.ts</span><br><span class="line">│   │   │   │   ├── span</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── taro-camera</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── taro-canvas</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── taro-image</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── taro-input</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── taro-label</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── taro-map</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── taro-picker</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── taro-textarea</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   ├── taro-video</span><br><span class="line">│   │   │   │   │   └── index.ts</span><br><span class="line">│   │   │   │   └── text</span><br><span class="line">│   │   │   │       └── index.ts</span><br><span class="line">│   │   │   └── utils.ts</span><br><span class="line">│   │   └── template-rewriter.ts</span><br><span class="line">│   ├── rn</span><br><span class="line">│   │   ├── StyleSheet</span><br><span class="line">│   │   │   ├── ColorPropType.ts</span><br><span class="line">│   │   │   ├── ImageResizeMode.ts</span><br><span class="line">│   │   │   ├── ImageStylePropTypes.ts</span><br><span class="line">│   │   │   ├── LayoutPropTypes.ts</span><br><span class="line">│   │   │   ├── ShadowPropTypesIOS.ts</span><br><span class="line">│   │   │   ├── StyleSheetValidation.ts</span><br><span class="line">│   │   │   ├── TextStylePropTypes.ts</span><br><span class="line">│   │   │   ├── TransformPropTypes.ts</span><br><span class="line">│   │   │   ├── ViewStylePropTypes.ts</span><br><span class="line">│   │   │   ├── deprecatedPropType.ts</span><br><span class="line">│   │   │   ├── index.ts</span><br><span class="line">│   │   │   └── normalizeColor.ts</span><br><span class="line">│   │   ├── styleProcess.ts</span><br><span class="line">│   │   └── transformJS.ts</span><br><span class="line">│   ├── rn.ts   <span class="comment">// 构建React Native 平台代码</span></span><br><span class="line">│   ├── taro-config</span><br><span class="line">│   │   └── index.ts</span><br><span class="line">│   ├── ui.ts   <span class="comment">// 一系列工具函数</span></span><br><span class="line">│   └── util</span><br><span class="line">│       ├── astConvert.ts</span><br><span class="line">│       ├── constants.ts</span><br><span class="line">│       ├── dowload.ts</span><br><span class="line">│       ├── hash.ts</span><br><span class="line">│       ├── index.ts</span><br><span class="line">│       ├── npm.ts</span><br><span class="line">│       ├── npmExact.ts</span><br><span class="line">│       ├── resolve_npm_files.ts</span><br><span class="line">│       └── types.ts</span><br><span class="line">├── templates    <span class="comment">// 脚手架模版</span></span><br><span class="line">│   └── <span class="keyword">default</span></span><br><span class="line">│       ├── _editorconfig</span><br><span class="line">│       ├── _eslintrc</span><br><span class="line">│       ├── _gitignore</span><br><span class="line">│       ├── _npmrc</span><br><span class="line">│       ├── config</span><br><span class="line">│       │   ├── dev.js</span><br><span class="line">│       │   ├── index.js</span><br><span class="line">│       │   └── prod.js</span><br><span class="line">│       ├── global.d.ts</span><br><span class="line">│       ├── package.json</span><br><span class="line">│       ├── project.config.json</span><br><span class="line">│       ├── src         <span class="comment">// 初始化文件及目录，copy模版等</span></span><br><span class="line">│       │   ├── app.css</span><br><span class="line">│       │   ├── app.jsx</span><br><span class="line">│       │   ├── index.html</span><br><span class="line">│       │   └── pages</span><br><span class="line">│       │       └── index</span><br><span class="line">│       │           ├── index.css</span><br><span class="line">│       │           └── index.jsx</span><br><span class="line">│       ├── template_creator.js</span><br><span class="line">│       └── tsconfig.json</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── tslint.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><h3 id="taro-init"><a href="#taro-init" class="headerlink" title="taro init:"></a>taro init:</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g82dhdr37hj311m0cyq42.jpg" alt=""></p><h3 id="taro-命令入口"><a href="#taro-命令入口" class="headerlink" title="taro 命令入口"></a>taro 命令入口</h3><p>那么 taro 命令是怎样添加进去的呢，其原因在于 package.json 里面的 bin 字段；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_moudle/taro-cli/package.json</span></span><br><span class="line"><span class="string">"bin"</span>: &#123;</span><br><span class="line">    <span class="string">"taro"</span>: <span class="string">"bin/taro"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>taro 命令对应的可执行文件为 bin/taro<br>npm 会寻找这个文件，在 [prefix]/bin 目录下建立符号链接。在上面的例子中，taro会建立符号链接 [prefix]/bin/taro。由于 [prefix]/bin 目录会在运行时加入系统的 PATH 变量，因此在运行 npm 时，就可以不带路径，直接通过命令来调用这些脚本。</p><p>关于prefix，可以通过npm config get prefix获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="keyword">get</span> prefix</span><br><span class="line">/usr/local</span><br></pre></td></tr></table></figure><p>通过下列命令可以更加清晰的看到它们之间的符号链接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al <span class="string">`which taro`</span></span><br><span class="line">lrwxr-xr-x  <span class="number">1</span> chengshuai  admin  <span class="number">40</span>  <span class="number">6</span> <span class="number">15</span> <span class="number">10</span>:<span class="number">51</span> /usr/local/bin/taro -&gt; ../lib/node_modules/@tarojs/cli/bin/taro</span><br></pre></td></tr></table></figure><h3 id="taro-子命令"><a href="#taro-子命令" class="headerlink" title="taro 子命令"></a>taro 子命令</h3><p>上面我们已经知道 taro-cli 包安装之后，taro 命令是怎么和 /bin/taro 文件相关联起来的， 那 taro init 和 taro build 又是怎样和对应的文件关联起来的呢？</p><p><a href="https://github.com/tj/commander.js/" target="_blank" rel="noopener">tj/commander.js</a><br>命令行接口全面的解决方案，灵感来自于 Ruby’s commander。可以自动的解析命令和参数，合并多选项，处理短参等等，功能强大，上手简单</p><h4 id="命令关联与参数解析"><a href="#命令关联与参数解析" class="headerlink" title="命令关联与参数解析"></a>命令关联与参数解析</h4><p>commander 支持 git 风格的子命令处理，可以根据子命令自动引导到以特定格式命名的命令执行文件，文件名的格式是 [command]-[subcommand]，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taro init =&gt; taro-init</span><br><span class="line">taro build =&gt; taro-build</span><br></pre></td></tr></table></figure><p>/bin/taro 文件内容不多，核心代码也就那几行 .command() 命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; getPkgVersion, printPkgVersion &#125; = <span class="built_in">require</span>(<span class="string">'../dist/util'</span>)</span><br><span class="line"></span><br><span class="line">printPkgVersion()</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .version(getPkgVersion())</span><br><span class="line">  .usage(<span class="string">'&lt;command&gt; [options]'</span>)</span><br><span class="line">  .command(<span class="string">'init [projectName]'</span>, <span class="string">'Init a project with default templete'</span>)</span><br><span class="line">  .command(<span class="string">'config &lt;cmd&gt;'</span>, <span class="string">'Taro config'</span>)</span><br><span class="line">  .command(<span class="string">'create'</span>, <span class="string">'Create page for project'</span>)</span><br><span class="line">  .command(<span class="string">'build'</span>, <span class="string">'Build a project with options'</span>)</span><br><span class="line">  .command(<span class="string">'update'</span>, <span class="string">'Update packages of taro'</span>)</span><br><span class="line">  .command(<span class="string">'convert'</span>, <span class="string">'Convert weapp to taro'</span>)</span><br><span class="line">  .command(<span class="string">'info'</span>, <span class="string">'Diagnostics Taro env info'</span>)</span><br><span class="line">  .command(<span class="string">'doctor'</span>, <span class="string">'Diagnose taro project'</span>)</span><br><span class="line">  .parse(process.argv)</span><br></pre></td></tr></table></figure><h4 id="command方法"><a href="#command方法" class="headerlink" title="command方法"></a>command方法</h4><blockquote><p>用法：.command(‘init <path>‘, ‘description’)<br>command的 原则上他可以接受三个参数，第一个为命令定义，第二个命令描述，第三个为命令辅助修饰对象。</p></blockquote><ul><li><p>第一个参数中可以使用 &lt;&gt; 或者 [] 修饰命令参数</p></li><li><p>第二个参数可选。</p><ol><li>当没有第二个参数时，commander.js 将返回 Command 对象，若有第二个参数，将返回原型对象。</li><li>当带有第二个参数，并且没有显示调用 action(fn) 时，则将会使用子命令模式。</li><li>所谓子命令模式即，./pm，./pm-install，./pm-search等。这些子命令跟主命令在不同的文件中。</li></ol></li><li><p>第三个参数一般不用，它可以设置是否显示的使用子命令模式</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;taro-cli-是怎么玩的？&quot;&gt;&lt;a href=&quot;#taro-cli-是怎么玩的？&quot; class=&quot;headerlink&quot; title=&quot;taro-cli 是怎么玩的？&quot;&gt;&lt;/a&gt;taro-cli 是怎么玩的？&lt;/h3&gt;&lt;p&gt;所有的工程化项目都一样，肯定需要CL
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Taro介绍</title>
    <link href="https://jacob1811.github.io/blog/2019/11/27/Taro%E4%BB%8B%E7%BB%8D/"/>
    <id>https://jacob1811.github.io/blog/2019/11/27/Taro介绍/</id>
    <published>2019-11-27T07:54:37.000Z</published>
    <updated>2019-11-27T07:54:53.430Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章<br><a href="https://aotu.io/notes/2018/06/07/Taro/index.html" target="_blank" rel="noopener">多端统一开发框架 - Taro</a></p><h3 id="Taro是什么？"><a href="#Taro是什么？" class="headerlink" title="Taro是什么？"></a>Taro是什么？</h3><p><a href="https://github.com/NervJS/taro" target="_blank" rel="noopener">Taro github</a><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g889tg83x3j313202yaad.jpg" alt=""><br>Taro 是由凹凸实验室打造的一套遵循 React 语法规范的多端统一开发框架。<br>多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信/百度/支付宝/字节跳动/ QQ 小程序、快应用、H5、React Native 等的应用</p><p>总结：一次编写，多端运行</p><h3 id="Taro-设计技术"><a href="#Taro-设计技术" class="headerlink" title="Taro 设计技术"></a>Taro 设计技术</h3><p>对于微信小程序这样不开放不开源的端，我们可以先把 React 代码分析成一颗抽象语法树，根据这颗树生成小程序支持的模板代码，再做一个小程序运行时框架处理事件和生命周期与小程序框架兼容，然后把业务代码跑在运行时框架就完成了小程序端的适配。</p><p>对于 React 已经支持的端，例如 Web、React Native 甚至未来的 React VR，我们只要包一层组件库再做些许样式支持即可。鉴于时下小程序的热度和我们团队本身的业务侧重程度，组件库的 API 是以小程序为标准，其他端的组件库的 API 都会和小程序端的组件保持一致。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88954w3toj311y08a3zl.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g878ku2rgyj30v80u0adw.jpg" alt=""></p><h3 id="现代前端开发流程"><a href="#现代前端开发流程" class="headerlink" title="现代前端开发流程"></a>现代前端开发流程</h3><p>和微信自带的小程序框架不一样，Taro 积极拥抱社区现有的现代开发流程，包括但不限于：</p><p>NPM 包管理系统<br>ES6+ 语法<br>自由的资源引用<br>CSS 预处理器和后处理器（SCSS、Less、PostCSS）</p><p>对于微信小程序的编译流程，我们从 Parcel 得到灵感，自研了一套打包机制将 AST 不断传递，因此代码分析的速度得到了很大的提高。一台 2015 年 的 15寸 RMBP 在编译上百个组件时仅需要大约 15 秒左右。</p><h3 id="和-React-完全一致的-API-和组件化系统"><a href="#和-React-完全一致的-API-和组件化系统" class="headerlink" title="和 React 完全一致的 API 和组件化系统"></a>和 React 完全一致的 API 和组件化系统</h3><blockquote><p>在 Taro 中，你不用像小程序一样区分什么是 App 组件，什么是 Page 组件，什么是 Component 组件，Taro 全都是 Component 组件，并且和 React 的生命周期完全一致</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个典型的 Taro 组件</span></span><br><span class="line"><span class="keyword">import</span> Taro, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; View, Button &#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      title: <span class="string">'首页'</span>,</span><br><span class="line">      list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentWillMount () &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount () &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  componentWillUpdate (nextProps, nextState) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate (prevProps, prevState) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  shouldComponentUpdate (nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dosth</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; list, title &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View className=<span class="string">'index'</span>&gt;</span><br><span class="line">        &lt;View className=<span class="string">'title'</span>&gt;&#123;title&#125;&lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &lt;View className='content'&gt;</span></span><br><span class="line"><span class="regexp">          &#123;list.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return (</span></span><br><span class="line"><span class="regexp">              &lt;View className='item'&gt;&#123;item&#125;&lt;/</span>View&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">          &lt;Button className=<span class="string">'add'</span> onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;添加&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>View&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="各种小程序对比"><a href="#各种小程序对比" class="headerlink" title="各种小程序对比"></a>各种小程序对比</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g878iz61rvj315m0u07bz.jpg" alt=""></p><p><a href="https://github.com/yingye/Blog/issues/3" target="_blank" rel="noopener">wepy编译原理</a></p><h3 id="支持小程序端分包加载以及插件引用"><a href="#支持小程序端分包加载以及插件引用" class="headerlink" title="支持小程序端分包加载以及插件引用"></a>支持小程序端分包加载以及插件引用</h3><p>Taro 中也加入对原生小程序分包加载功能的支持，配置的方式与原生小程序基本一致，只需要在 app.js 入口文件中加入 subPackage 字段即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  config = &#123;</span><br><span class="line">    pages: [</span><br><span class="line">      <span class="string">'pages/index'</span>,</span><br><span class="line">      <span class="string">'pages/logs'</span></span><br><span class="line">    ],</span><br><span class="line">    subPackages: [</span><br><span class="line">      &#123;</span><br><span class="line">        root: <span class="string">'moduleA'</span>,</span><br><span class="line">        pages: [</span><br><span class="line">          <span class="string">'pages/rabbit'</span>,</span><br><span class="line">          <span class="string">'pages/squirrel'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Taro 也支持了使用小程序的插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; View &#125; <span class="keyword">from</span> <span class="string">'@tarojs/Components'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  config = &#123;</span><br><span class="line">    usingComponents: &#123;</span><br><span class="line">      <span class="string">'hello-component'</span>: <span class="string">'plugin://myPlugin/hello-component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;hello-component&gt;<span class="xml"><span class="tag">&lt;/<span class="name">hello-component</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://aotu.io/notes/2018/11/30/taro_practice/" target="_blank" rel="noopener">最佳实践</a></p><h3 id="为什么选择使用React语法"><a href="#为什么选择使用React语法" class="headerlink" title="为什么选择使用React语法"></a>为什么选择使用React语法</h3><p>这个要从两个方面来说，一是小程序原生的开发方式不够友好，或者说不够工程化，在开发一些大型项目时就会显得很吃力，主要体现在以下几点：</p><p>一个小程序页面或组件，需要同时包含 4 个文件，以至开发一个功能模块时，需要多个文件间来回切换<br>没有自定义文件预处理，无法直接使用 Sass、Less 以及较新的 ES Next 语法<br>字符串模板太过孱弱，小程序的字符串模板仿的是 Vue，但是没有提供 Vue 那么多的语法糖，当实现一些比较复杂的处理时，写起来就非常麻烦，虽然提供了 wxs 作为补充，但是使用体验还是非常糟糕<br>缺乏测试套件，无法编写测试代码来保证项目质量，也就不能进行持续集成，自动化打包<br>原生的开发方式不友好，自然就想要有更高效的替代方案。所以我们将目光投向了市面上流行的三大前端框架React、Vue、Angular 。Angular在国内的流行程度不高，我们首先排除了这种语法规范。而类 Vue 的小程序开发框架市面上已经有一些优秀的开源项目，同时我们部门内的技术栈主要是 React，那么 React 语法规范 也自然成为了我们的第一选择。除此之外，我们还有以下几点的考虑：</p><p>React 一门非常流行的框架，也有广大的受众，使用它也能降低小程序开发的学习成本<br>小程序的数据驱动模板更新的思想与实现机制，与 React 类似<br>React 采用 JSX 作为自身模板，JSX 相比字符串模板来说更加自由，更自然，更具表现力，不需要依赖字符串模板的各种语法糖，也能完成复杂的处理<br>React 本身有跨端的实现方案 ReactNative，并且非常成熟，社区活跃，对于 Taro 来说有更多的多端开发可能性<br>综上所述，Taro 最终采用了 React 语法 来作为自己的语法标准，配合前端工程化的思想，为小程序开发打造了更加优雅的开发体验。</p><h3 id="redux-结构"><a href="#redux-结构" class="headerlink" title="redux 结构"></a>redux 结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── config</span><br><span class="line">│   ├── dev.js</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── prod.js</span><br><span class="line">├── dist</span><br><span class="line">│   ├── actions</span><br><span class="line">│   │   └── counter.js</span><br><span class="line">│   ├── app.js</span><br><span class="line">│   ├── app.json</span><br><span class="line">│   ├── app.wxss</span><br><span class="line">│   ├── constants</span><br><span class="line">│   │   └── counter.js</span><br><span class="line">│   ├── npm</span><br><span class="line">│   │   ├── @tarojs</span><br><span class="line">│   │   ├── promise-polyfill</span><br><span class="line">│   │   ├── redux</span><br><span class="line">│   │   ├── redux-logger</span><br><span class="line">│   │   ├── redux-thunk</span><br><span class="line">│   │   ├── regenerator-runtime</span><br><span class="line">│   │   ├── symbol-observable</span><br><span class="line">│   │   └── tslib</span><br><span class="line">│   ├── pages</span><br><span class="line">│   │   └── index</span><br><span class="line">│   ├── project.config.json</span><br><span class="line">│   ├── reducers</span><br><span class="line">│   │   ├── counter.js</span><br><span class="line">│   │   └── index.js</span><br><span class="line">│   ├── sitemap.json</span><br><span class="line">│   └── store</span><br><span class="line">│       └── index.js</span><br><span class="line">├── global.d.ts</span><br><span class="line">├── package.json</span><br><span class="line">├── project.config.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── actions</span><br><span class="line">│   │   └── counter.ts</span><br><span class="line">│   ├── app.less</span><br><span class="line">│   ├── app.tsx</span><br><span class="line">│   ├── constants</span><br><span class="line">│   │   └── counter.ts</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── pages</span><br><span class="line">│   │   └── index</span><br><span class="line">│   ├── reducers</span><br><span class="line">│   │   ├── counter.ts</span><br><span class="line">│   │   └── index.ts</span><br><span class="line">│   └── store</span><br><span class="line">│       └── index.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>可以借鉴一下：<br>组件都放在components里面。里面的目录是这样的，假如有个coupon优惠券页面，在pages自然先有个coupon，作为页面入口，然后它的组件就会存放在components/coupon里面，就是components里面也会按照页面分模块，公共的组件可以建一个components/public文件夹，进行复用</p><p>这样的好处是页面之间互相独立，互不影响。所以我们几个开发人员，也是按照页面的维度来进行分工，互不干扰，大大提高了我们的开发效率。</p><p>actions这个文件夹也是比较重要，这里处理的是拉取数据，数据再处理的逻辑。可以说，数据处理得好，流动清晰，整个项目就成功了一半，具体可以看下面数据状态管理的部分。如上，假如是coupon页面的actions，那么就会放在actions/coupon里面，可以再一次见到，所有的模块都是以页面的维度来区分的。</p><p>除此之外，asset文件用来存放的静态资源，如一些icon类的图片，但建议不要存放太多，毕竟程序包有限制。而constants则是一些存放常量的地方，例如api域名，配置等等。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="setState的使用"><a href="#setState的使用" class="headerlink" title="setState的使用"></a>setState的使用</h4><p>实在小程序的开发中，最大可能的会遇到的性能问题，大多数出现在setData（具体到 Taro 中就是调用 setState 函数）上。这是由小程序的设计机制所导致的，每调用一次 setData，小程序内部都会将该部分数据在逻辑层（运行环境 JSCore）进行类似序列化的操作，将数据转换成字符串形式传递给视图层（运行环境 WebView），视图层通过反序列化拿到数据后再进行页面渲染，这个过程下来有一定性能开销。</p><p>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境，在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。在调用 setData 之后，会将数据使用 JSON.stringify 进行序列化，再拼接成脚本，然后再传给视图层渲染，这样的话，当数据量非常大的时候，小程序就会变得异常卡顿，性能很差。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87zrz1y8wj31do0dignd.jpg" alt=""></p><p>所以关于setState的使用，有以下几个原则<br>避免一次性更新巨大的数据。这个更多的是组件设计的问题，在平衡好开发效率的情况下尽可能地细分组件。<br>避免频繁地调用 setState。实际上在 Taro 中 setState 是异步的，并且在编译过程中会帮你做了这层优化，例如一个函数里调用了两次 setState，最后 Taro 会在下一个事件循环中将两者合并，并剔除重复数据。<br>避免后台态页面进行 setState。这个更有可能是因为在定时器等异步操作中使用了 setState，导致后台态页面进行了 setState 操作。要解决问题该就在页面销毁或是隐藏时进行销毁定时器操作即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始 state</span></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  a: [<span class="number">0</span>],</span><br><span class="line">  b: &#123;</span><br><span class="line">    x: &#123;</span><br><span class="line">      y: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 this.setState</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  a: [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  b: &#123;</span><br><span class="line">    x: &#123;</span><br><span class="line">      y: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不优化</span></span><br><span class="line"><span class="keyword">this</span>.$scope.setData(&#123;</span><br><span class="line">  a: [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  b: &#123;</span><br><span class="line">    x: &#123;</span><br><span class="line">      y: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">this</span>.$scope.setData(&#123;</span><br><span class="line">  <span class="string">'a[0]'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'a[1]'</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'b.x.y'</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="列表渲染优化"><a href="#列表渲染优化" class="headerlink" title="列表渲染优化"></a>列表渲染优化</h4><p>当加载的商品数据越来越多时，就会报错，invokeWebviewMethod 数据传输长度为 1227297 已经超过最大长度 1048576。原因就是我们上面所说的，小程序在 setData 的时候会将该部分数据在逻辑层与视图层之间传递，当数据量过大时就会超出限制。</p><p>所有的原始数据放在list中，然后判断根据页面的滚动高度，在页面滚动事件中判断当前的页码。页码小于10，取 list.slice 的前十项，大于等于10，则取后十项，最后再调用 this.setState 进行列表渲染。这里的核心思想就是，把看得见的数据才渲染出来，从而避免数据量过大而导致的报错<br>同时为了提前渲染，我们会预设一个500的阈值，使整个渲染切换的流程更加顺畅。</p><h4 id="多端兼容"><a href="#多端兼容" class="headerlink" title="多端兼容"></a>多端兼容</h4><p>使用process.env.TARO_ENV可以帮助我们判断当前的编译环境，从而做一些特殊处理，目前它的取值有 weapp 、swan 、 alipay 、 h5 、 rn 五个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'weapp'</span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'path/to/weapp/name'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'path/to/h5/name'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滚动事件兼容"><a href="#滚动事件兼容" class="headerlink" title="滚动事件兼容"></a>滚动事件兼容</h4><p>在小程序中，监听页面滚动需要在页面中的onPageScroll事件里进行，而在 H5 中则是需要手动调用window.addEventListener来进行事件绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(...arguments)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.pageScrollFn = throttle(<span class="keyword">this</span>.scrollFn, <span class="number">200</span>, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  scrollFn = <span class="function">(<span class="params">scrollTop</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在H5或者其它端中，这个函数会被忽略</span></span><br><span class="line">  onPageScroll (e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pageScrollFn(e.scrollTop)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="comment">// 只有编译为h5时下面代码才会被编译</span></span><br><span class="line"><span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="keyword">this</span>.pageScrollFn)</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="canvas兼容"><a href="#canvas兼容" class="headerlink" title="canvas兼容"></a>canvas兼容</h4><p>canvas 在小程序和 H5 中的 API 基本都是一致的，但有几点不同:<br>canvas 上下文的获取方式不同，h5 中是直接从 dom 中获取；而小程序里要通过调用 Taro.createCanvasContext 来手动创建<br>绘制时，小程序里还需在手动调用 CanvasContext.draw 来进行绘制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">    <span class="comment">// 只有编译为h5下面代码才会被编译</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.context = <span class="built_in">document</span>.getElementById(<span class="string">'canvas-id'</span>).getContext(<span class="string">'2d'</span>)</span><br><span class="line">    <span class="comment">// 只有编译为小程序下面代码才会被编译</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'weapp'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.context = Taro.createCanvasContext(<span class="string">'canvas-id'</span>, <span class="keyword">this</span>.$scope)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制的函数</span></span><br><span class="line">draw () &#123;</span><br><span class="line">    <span class="comment">// 进行一些绘制操作</span></span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容小程序端的绘制</span></span><br><span class="line">    <span class="keyword">typeof</span> <span class="keyword">this</span>.context.draw === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.context.draw(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="comment">// 同时标记上id和canvas-id</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Canvas</span> <span class="attr">id</span>=<span class="string">'canvas-id'</span> <span class="attr">canvas-id</span>=<span class="string">'canvas-id'</span>/&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="ui"><a href="#ui" class="headerlink" title="ui"></a>ui</h3><p><a href="https://taro-ui.aotu.io/#/" target="_blank" rel="noopener">Taro-ui</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g880mztj79j31bu0u00yz.jpg" alt=""></p><h3 id="将已有微信小程序转换为多端应用-Taro"><a href="#将已有微信小程序转换为多端应用-Taro" class="headerlink" title="将已有微信小程序转换为多端应用(Taro)"></a>将已有微信小程序转换为多端应用(Taro)</h3><p><a href="https://github.com/NervJS/taro/issues/955" target="_blank" rel="noopener">!!! 只能原生，不支持wepy等第三方框架</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">taro convert </span><br><span class="line"><span class="comment">// 根目录下生成taroConvert文件夹</span></span><br><span class="line"></span><br><span class="line">cd taroConvert </span><br><span class="line">cnpm i</span><br><span class="line"></span><br><span class="line">npm run dev:weapp</span><br></pre></td></tr></table></figure><h4 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h4><p><a href="https://github.com/RebeccaHanjw/weapp-wechat-zhihu" target="_blank" rel="noopener">github开源小程序项目-知乎</a><br><a href="https://nervjs.github.io/taro/docs/taroize.html" target="_blank" rel="noopener">Taro转换原理</a><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g882rczljaj314h0u0115.jpg" alt=""></p><h4 id="页面文件对比"><a href="#页面文件对比" class="headerlink" title="页面文件对比"></a>页面文件对比</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g882t4kd4sj30hi0te75x.jpg" alt=""></p><p>//js对比<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g882uk11fzj30yb0gs0vd.jpg" alt=""></p><p>//html对比<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g882ws6zvsj30zb0ef784.jpg" alt=""></p><p>最重要的区别就在于 @withWeapp() 这个装饰器，你可以将它理解为转换代码的运行时，@withWeapp() 会增加一些原来 Taro 没有方法和属性</p><h4 id="this-setData"><a href="#this-setData" class="headerlink" title="this.setData"></a>this.setData</h4><p>转换后的 this.setData 的 API 相当于小程序的 this.setData 的 polyfill，他和 this.setState 最大的区别就在于，this.setData 之后 data 的数据是同步更新，而渲染是异步更新，而 setState 两者都是异步的。</p><h4 id="this-data-和-this-properties"><a href="#this-data-和-this-properties" class="headerlink" title="this.data 和 this.properties"></a>this.data 和 this.properties</h4><p>this.data 和 this.properties 相当于 Taro 的 this.state 和 this.props 的 alias，当它们的数据更新时，对应的 state 和 props 也会同步更新。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Taro 会将原始文件的生命周期钩子函数转换为 Taro 的生命周期<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8833fh6svj30lo0osju6.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文章&lt;br&gt;&lt;a href=&quot;https://aotu.io/notes/2018/06/07/Taro/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多端统一开发框架 - Taro
&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Taro是什
      
    
    </summary>
    
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/tags/react/"/>
    
      <category term="Taro" scheme="https://jacob1811.github.io/blog/tags/Taro/"/>
    
  </entry>
  
  <entry>
    <title>Taro快速开始</title>
    <link href="https://jacob1811.github.io/blog/2019/11/27/Taro%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
    <id>https://jacob1811.github.io/blog/2019/11/27/Taro快速开始/</id>
    <published>2019-11-27T07:53:47.000Z</published>
    <updated>2019-12-31T12:06:19.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Taro"><a href="#Taro" class="headerlink" title="Taro"></a>Taro</h2><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><blockquote><p>node &gt;=8.0.0</p></blockquote><h3 id="CLI-工具安装"><a href="#CLI-工具安装" class="headerlink" title="CLI 工具安装"></a>CLI 工具安装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用 npm 安装 CLI</span><br><span class="line">$ npm install -g @tarojs/cli</span><br><span class="line"># OR 使用 yarn 安装 CLI</span><br><span class="line">$ yarn global add @tarojs/cli</span><br><span class="line"># OR 安装了 cnpm，使用 cnpm 安装 CLI</span><br><span class="line">$ cnpm install -g @tarojs/cli</span><br></pre></td></tr></table></figure><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ taro init myApp</span><br><span class="line">cd myApp</span><br><span class="line">yarn</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># yarn</span><br><span class="line">$ yarn dev:weapp</span><br><span class="line">$ yarn build:weapp</span><br><span class="line"># npm script</span><br><span class="line">$ npm run dev:weapp</span><br><span class="line">$ npm run build:weapp</span><br><span class="line"># 仅限全局安装</span><br><span class="line">$ taro build --type weapp --watch</span><br><span class="line">$ taro build --type weapp</span><br><span class="line"># npx 用户也可以使用</span><br><span class="line">$ npx taro build --type weapp --watch</span><br><span class="line">$ npx taro build --type weapp</span><br></pre></td></tr></table></figure><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── config                 配置目录</span><br><span class="line">|   ├── dev.js             开发时配置</span><br><span class="line">|   ├── index.js           默认配置</span><br><span class="line">|   └── prod.js            打包时配置</span><br><span class="line">├── src                    源码目录</span><br><span class="line">|   ├── components         公共组件目录</span><br><span class="line">|   ├── pages              页面文件目录</span><br><span class="line">|   |   ├── index          index 页面目录</span><br><span class="line">|   |   |   ├── banner     页面 index 私有组件</span><br><span class="line">|   |   |   ├── index.js   index 页面逻辑</span><br><span class="line">|   |   |   └── index.css  index 页面样式</span><br><span class="line">|   ├── utils              公共方法库</span><br><span class="line">|   ├── app.css            项目总通用样式</span><br><span class="line">|   └── app.js             项目入口文件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><blockquote><p>Taro 中普通 JS/TS 文件以小写字母命名，多个单词以下划线连接，例如 util.js、util_helper.js</p></blockquote><blockquote><p>Taro 组件文件命名遵循 Pascal 命名法，例如 ReservationCard.jsx</p></blockquote><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p><a href="https://taro-docs.jd.com/taro/docs/best-practice.html" target="_blank" rel="noopener">https://taro-docs.jd.com/taro/docs/best-practice.html</a></p><h4 id="JSX-支持程度说明"><a href="#JSX-支持程度说明" class="headerlink" title="JSX 支持程度说明"></a>JSX 支持程度说明</h4><ol><li><p><a href="https://github.com/NervJS/taro/blob/master/packages/eslint-plugin-taro/docs/manipulate-jsx-as-array.md" target="_blank" rel="noopener">不能使用 Array#map 之外的方法操作 JSX 数组</a></p></li><li><p><a href="https://github.com/NervJS/taro/blob/master/packages/eslint-plugin-taro/docs/no-jsx-in-class-method.md" target="_blank" rel="noopener">暂不支持在 render() 之外的方法定义 JSX</a></p></li><li><p><a href="https://github.com/NervJS/taro/blob/master/packages/eslint-plugin-taro/docs/no-spread-in-props.md" target="_blank" rel="noopener">不能在 JSX 参数中使用对象展开符 </a></p></li><li><p><a href="https://github.com/NervJS/taro/blob/master/packages/eslint-plugin-taro/docs/no-stateless-function.md" target="_blank" rel="noopener">不支持无状态组件</a></p></li></ol><h4 id="最佳编码方式"><a href="#最佳编码方式" class="headerlink" title="最佳编码方式"></a>最佳编码方式</h4><h4 id="组件样式说明"><a href="#组件样式说明" class="headerlink" title="组件样式说明"></a>组件样式说明</h4><h5 id="给组件设置-defaultProps"><a href="#给组件设置-defaultProps" class="headerlink" title="给组件设置 defaultProps"></a>给组件设置 defaultProps</h5><blockquote><p>在微信小程序端的自定义组件中，只有在 properties 中指定的属性，才能从父组件传入并接收</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    myProperty: &#123; // 属性名</span><br><span class="line">      type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）</span><br><span class="line">      value: &apos;&apos;, // 属性初始值（可选），如果未指定则会根据类型选择一个</span><br><span class="line">      observer: function (newVal, oldVal, changedPath) &#123;</span><br><span class="line">         // 属性被改变时执行的函数（可选），也可以写成在 methods 段中定义的方法名字符串, 如：&apos;_propertyChange&apos;</span><br><span class="line">         // 通常 newVal 就是新设置的数据， oldVal 是旧数据</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    myProperty2: String // 简化的定义方式</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="组件传递函数属性名以-on-开头"><a href="#组件传递函数属性名以-on-开头" class="headerlink" title="组件传递函数属性名以 on 开头"></a>组件传递函数属性名以 on 开头</h5><blockquote><p>在 v1.3.0-beta.0 之后，自定义组件间的事件传递可以不用 on 开头，但内置组件的事件依然是以 on 开头的，为了一致性我们仍然推荐你以 on 开头命名你的事件。</p></blockquote><p>在 Taro 中，父组件要往子组件传递函数，属性名必须以 on 开头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 调用 Custom 组件，传入 handleEvent 函数，属性名为 onTrigger</span><br><span class="line">class Parent extends Component &#123;</span><br><span class="line"></span><br><span class="line">  handleEvent () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Custom onTrigger=&#123;this.handleEvent&#125;&gt;&lt;/Custom&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为，微信小程序端组件化是不能直接传递函数类型给子组件的，在 Taro 中是借助组件的事件机制来实现这一特性，而小程序中传入事件的时候属性名写法为 bindmyevent 或者 bind:myevent</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当自定义组件触发 myevent 事件时，调用 onMyEvent 方法 --&gt;</span><br><span class="line">&lt;component-tag-name bindmyevent=<span class="string">"onMyEvent"</span> /&gt;</span><br><span class="line">&lt;!-- 或者可以写成 --&gt;</span><br><span class="line">&lt;component-tag-name bind:myevent=<span class="string">"onMyEvent"</span> /&gt;</span><br></pre></td></tr></table></figure><p>所以 Taro 中约定组件传递函数属性名以 on 开头，同时这也和内置组件的事件绑定写法保持一致了。</p><h5 id="小程序端不要在组件中打印传入的函数"><a href="#小程序端不要在组件中打印传入的函数" class="headerlink" title="小程序端不要在组件中打印传入的函数"></a>小程序端不要在组件中打印传入的函数</h5><blockquote><p>前面已经提到小程序端的组件传入函数的原理，所以在小程序端不要在组件中打印传入的函数，因为拿不到结果，但是 this.props.onXxx &amp;&amp; this.props.onXxx() 这种判断函数是否传入来进行调用的写法是完全支持的。</p></blockquote><h5 id="小程序端不要将在模板中用到的数据设置为-undefined"><a href="#小程序端不要将在模板中用到的数据设置为-undefined" class="headerlink" title="小程序端不要将在模板中用到的数据设置为 undefined"></a>小程序端不要将在模板中用到的数据设置为 undefined</h5><blockquote><p>由于小程序不支持将 data 中任何一项的 value 设为 undefined ，在 setState 的时候也请避免这么用。你可以使用 null 来替代。</p></blockquote><h5 id="小程序端不要在组件中打印-this-props-children"><a href="#小程序端不要在组件中打印-this-props-children" class="headerlink" title="小程序端不要在组件中打印 this.props.children"></a>小程序端不要在组件中打印 this.props.children</h5><blockquote><p>在微信小程序端是通过 <slot /> 来实现往自定义组件中传入元素的，而 Taro 利用 this.props.children 在编译时实现了这一功能， this.props.children 会直接被编译成 <slot /> 标签，所以它在小程序端属于语法糖的存在，请不要在组件中打印它。</p></blockquote><blockquote><p>支持 props 传入 JSX<br>支持 props 传入 JSX，但是元素传入 JSX 的属性名必须以 render 开头</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View className=<span class="string">'dialog'</span>&gt;</span><br><span class="line">        &lt;View className=<span class="string">'header'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.renderHeader&#125;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &lt;View className='body'&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>View&gt;</span><br><span class="line">        &lt;View className=<span class="string">'footer'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.renderFooter&#125;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View className=<span class="string">'container'</span>&gt;</span><br><span class="line">        &lt;Dialog</span><br><span class="line">          renderHeader=&#123;</span><br><span class="line">            &lt;View className=<span class="string">'welcome-message'</span>&gt;Welcome!<span class="xml"><span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">          &#125;</span><br><span class="line">          renderFooter=&#123;</span><br><span class="line">            &lt;Button className=<span class="string">'close'</span>&gt;Close&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          &lt;View className="dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">            Thank you for using Taro.</span></span><br><span class="line"><span class="regexp">          &lt;/</span>View&gt;</span><br><span class="line">        &lt;<span class="regexp">/Dialog&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不要以 id、class、style 作为自定义组件的属性与内部 state 的名称，因为这些属性名在微信小程序小程序中会丢失。</p></blockquote><blockquote><p>不要在 state 与 props 上用同名的字段，因为这些字段在微信小程序中都会挂在 data 上。</p></blockquote><p>小程序中页面生命周期 componentWillMount 不一致问题</p><blockquote><p>由于微信小程序里页面在 onLoad 时才能拿到页面的路由参数，而页面 onLoad 前组件都已经 attached 了。因此页面的 componentWillMount 可能会与预期不太一致</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="comment">// 在 willMount 之前无法拿到路由参数</span></span><br><span class="line">  <span class="keyword">const</span> abc = <span class="keyword">this</span>.$router.params.abc</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Custom</span> <span class="attr">adc</span>=<span class="string">&#123;abc&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 正确写法</span></span><br><span class="line"><span class="xml">componentWillMount () &#123;</span></span><br><span class="line"><span class="xml">  const abc = this.$router.params.abc</span></span><br><span class="line"><span class="xml">  this.setState(&#123;</span></span><br><span class="line"><span class="xml">    abc</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">render () &#123;</span></span><br><span class="line"><span class="xml">  // 增加一个兼容判断</span></span><br><span class="line">  return this.state.abc &amp;&amp; &lt;Custom adc=&#123;abc&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件的 constructor 与 render 提前调用</p><blockquote><p>很多细心的开发者应该已经注意到了，在 Taro 编译到小程序端后，组件的 constructor 与 render 默认会多调用一次，表现得与 React 不太一致。</p></blockquote><blockquote><p>这是因为，Taro 的组件编译后就是小程序的自定义组件，而小程序的自定义组件的初始化时是可以指定 data 来让组件拥有初始化数据的。开发者一般会在组件的 constructor 中设置一些初始化的 state，同时也可能会在 render 中处理 state 与 props 产生新的数据，在 Taro 中多出的这一次提前调用，就是为了收集组件的初始化数据，给自定义组件提前生成 data ，以保证组件初始化时能带有数据，让组件初次渲染正常。</p></blockquote><blockquote><p>所以，在编码时，需要在处理数据的时候做一些容错处理，这样可以避免在 constructor 与 render 提前调用时出现由于没有数据导致出错的情况。</p></blockquote><blockquote><p>在 Taro 中，JS 代码里必须书写单引号，特别是 JSX 中，如果出现双引号，可能会导致编译错误。</p></blockquote><blockquote><p>不要以解构的方式来获取通过 env 配置的 process.env 环境变量，请直接以完整书写的方式 process.env.NODE_ENV 来进行使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 错误写法，不支持</span><br><span class="line">const &#123; NODE_ENV = &apos;development&apos; &#125; = process.env</span><br><span class="line">if (NODE_ENV === &apos;development&apos;) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确写法</span><br><span class="line">if (process.env.NODE_ENV === &apos;development&apos;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>this.$componentType 可能取值分别为 PAGE 和 COMPONENT，开发者可以根据此变量的取值分别采取不同逻辑。</p></blockquote><blockquote><p>原生小程序组件传递 props 给 Taro 组件</p></blockquote><p>Taro v1.3+ 对 props 系统进行了改造，使得不能兼容原生组件通过 properties 传入的属性。</p><p>目前可以通过把所有需要传入 Taro 组件的 props，通过借助 extraProps 属性来解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 小程序组件常规 props 传递</span><br><span class="line">&lt;plugin title=&quot;&#123;&#123;name&#125;&#125;&quot; desc=&quot;&#123;&#123;desc&#125;&#125;&quot; bindonclick=&quot;onClick&quot;&gt;&lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">// 原生小程序组件调用 Taro 组件时需要改造成以下形式：</span><br><span class="line">this.setData(&#123;</span><br><span class="line">  extraProps: &#123;</span><br><span class="line">    name,</span><br><span class="line">    desc,</span><br><span class="line">    onClick: this.onClick</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;plugin extraProps=&quot;&#123;&#123;extraProps&#125;&#125;&quot; &gt;&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><blockquote><p>新增一个自行命名的 JS 文件，例如 global_data.js，示例代码如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const globalData = &#123;&#125;</span><br><span class="line"></span><br><span class="line">export function set (key, val) &#123;</span><br><span class="line">  globalData[key] = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function get (key) &#123;</span><br><span class="line">  return globalData[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>随后就可以在任意位置进行使用啦</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; set as setGlobalData, get as getGlobalData &#125; from &apos;./path/name/global_data&apos;</span><br><span class="line"></span><br><span class="line">setGlobalData(&apos;test&apos;, 1)</span><br><span class="line"></span><br><span class="line">getGlobalData(&apos;test&apos;)</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>taro的路由是自带的，不需要我们额外配置，只需要我们在app.js下config中配置pages即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    config = &#123;</span><br><span class="line">        pages: [</span><br><span class="line">            &apos;pages/test/test&apos;,</span><br><span class="line">            &apos;pages/index/index&apos;</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用   此处注意需要添加 ‘/’</span><br><span class="line">Taro.navigateTo(&#123;</span><br><span class="line">  url:&apos;/pages/test/test&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组件的外部样式和全局样式"><a href="#组件的外部样式和全局样式" class="headerlink" title="组件的外部样式和全局样式"></a>组件的外部样式和全局样式</h3><p>自定义组件对应的样式文件，只对该组件内的节点生效。编写组件样式时，需要注意以下几点：</p><ul><li>组件和引用组件的页面不能使用 id 选择器（#a）、属性选择器（[a]）和标签名选择器，请改用 class 选择器。</li><li>组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。</li><li>子元素选择器（.a &gt; .b）只能用于 View 组件与其子节点之间，用于其他组件可能导致非预期的情况。</li><li>继承样式，如 font 、 color ，会从组件外（父组件）继承到组件内。但是引用组件时在组件节点上书写的 className 无效。 （具体解决方案请参见下面的外部和全局样式介绍。）</li><li>除继承样式外， app.scss 中的样式、组件所在页面的样式，均对自定义组件无效。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#a &#123; &#125; /* 在组件中不能使用 */</span><br><span class="line">[a] &#123; &#125; <span class="comment">/* 在组件中不能使用 */</span></span><br><span class="line">button &#123; &#125; <span class="comment">/* 在组件中不能使用 */</span></span><br><span class="line">.a &gt; .b &#123; &#125; <span class="comment">/* 除非 .a 是 view 组件节点，否则不一定会生效 */</span></span><br></pre></td></tr></table></figure>除此以外，组件可以指定它所在节点的默认样式，使用 :host 选择器（需要包含基础库 1.7.2 或更高版本的开发者工具支持）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 该自定义组件的默认样式 */</span><br><span class="line">:host &#123;</span><br><span class="line">  color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外部样式类"><a href="#外部样式类" class="headerlink" title="外部样式类"></a>外部样式类</h3><p>如果想传递样式给引用的自定义组件，以下写法（直接传递 className）不可行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CustomComp.js */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    className: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;</span>&gt;</span>这段文本的颜色不会由组件外的 class 决定<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* MyPage.js */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CustomComp</span> <span class="attr">className</span>=<span class="string">"red-text"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">/* MyPage.scss */</span></span><br><span class="line"><span class="xml">.red-text &#123;</span></span><br><span class="line"><span class="xml">  color: red;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>取而代之的，需要利用 externalClasses 定义段定义若干个外部样式类。这个特性从小程序基础库版本 1.9.90 开始支持。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CustomComp.js */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> externalClasses = [<span class="string">'my-class'</span>]</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">className</span>=<span class="string">"my-class"</span>&gt;</span>这段文本的颜色由组件外的 class 决定<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MyPage.js */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CustomComp</span> <span class="attr">my-class</span>=<span class="string">"red-text"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">/* MyPage.scss */</span></span><br><span class="line"><span class="xml">.red-text &#123;</span></span><br><span class="line"><span class="xml">  color: red;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：externalClasses 需要使用 短横线命名法 (kebab-case)，而不是 React 惯用的 驼峰命名法 (camelCase)。否则无效。</p></blockquote><h3 id="全局样式类"><a href="#全局样式类" class="headerlink" title="全局样式类"></a>全局样式类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CustomComp.js */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> options = &#123;</span><br><span class="line">    addGlobalClass: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">className</span>=<span class="string">"red-text"</span>&gt;</span>这段文本的颜色由组件外的 class 决定<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 组件外的样式定义 */</span></span><br><span class="line">.red-text &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jsx"><a href="#Jsx" class="headerlink" title="Jsx"></a>Jsx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Taro, &#123; Component &#125; from &apos;@tarojs/taro&apos;</span><br><span class="line">import &#123; View &#125; from &apos;@tarojs/components&apos;</span><br><span class="line"></span><br><span class="line">class Home extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;Hello World!&lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须声明 Taro 和组件<br>首字母大写与驼峰式命名<br>React 可以使用 … 拓展操作符来传递属性，但在 Taro 中你不能这么做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = &#123;<span class="attr">firstName</span>: <span class="string">'Plus'</span>, <span class="attr">lastName</span>: <span class="string">'Second'</span>&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">//这样的操作会报错。你只能手动地把所有需要引用的 props 写上去：</span></span><br><span class="line"> &lt;Greeting firstName="Plus" lastName="Second" /&gt;</span><br></pre></td></tr></table></figure><h3 id="布尔值、Null-和-Undefined-被忽略"><a href="#布尔值、Null-和-Undefined-被忽略" class="headerlink" title="布尔值、Null 和 Undefined 被忽略"></a>布尔值、Null 和 Undefined 被忽略</h3><blockquote><p>false、null、undefined 和 true 都是有效的 children，但它们不会直接被渲染。下面的表达式是等价的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;View /&gt;</span><br><span class="line"></span><br><span class="line">&lt;View&gt;<span class="xml"><span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;View&gt;&#123;<span class="literal">false</span>&#125;&lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;View&gt;&#123;null&#125;&lt;/</span>View&gt;</span><br><span class="line"></span><br><span class="line">&lt;View&gt;&#123;<span class="literal">undefined</span>&#125;&lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;View&gt;&#123;true&#125;&lt;/</span>View&gt;</span><br></pre></td></tr></table></figure><h3 id="Taro-和-React-一样，也有一个严格的规则："><a href="#Taro-和-React-一样，也有一个严格的规则：" class="headerlink" title="Taro 和 React 一样，也有一个严格的规则："></a>Taro 和 React 一样，也有一个严格的规则：</h3><blockquote><p>所有的 Taro 组件必须像纯函数那样使用它们的 props。</p></blockquote><h4 id="使用-PropTypes-检查类型"><a href="#使用-PropTypes-检查类型" class="headerlink" title="使用 PropTypes 检查类型"></a>使用 PropTypes 检查类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;Hello, &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Greeting.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 如上例，Taro 与 React 一样，也支持 PropTypes 检查类型，目前在小程序端还有些问题，但在 H5 端可以使用，用法和在 React 里一样。 更多可参照 React 的相关文档。</span></span><br></pre></td></tr></table></figure><h3 id="生命周期-amp-State"><a href="#生命周期-amp-State" class="headerlink" title="生命周期 &amp; State"></a>生命周期 &amp; State</h3><h4 id="状态更新一定是异步的"><a href="#状态更新一定是异步的" class="headerlink" title="状态更新一定是异步的"></a>状态更新一定是异步的</h4><p>Taro 可以将多个 setState() 调用合并成一个调用来提高性能。</p><p>因为 this.state 和 props 一定是异步更新的，所以你不能在 setState 马上拿到 state 的值，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们之前设置了 this.state.counter = 0</span></span><br><span class="line">updateCounter () &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.counter) <span class="comment">// 这里 counter 还是 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的做法是这样，在 setState 的第二个参数传入一个 callback：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 假设我们之前设置了 this.state.counter = 0</span><br><span class="line">updateCounter () &#123;</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    counter: 1</span><br><span class="line">  &#125;, () =&gt; &#123;</span><br><span class="line">    // 在这个函数内你可以拿到 setState 之后的值</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>Taro 事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串 (DOM 元素的写法)。 例如，传统的微信小程序模板：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"activateLasers"</span>&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>Taro 中稍稍有点不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>在 Taro 中另一个不同是你不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation</p><h4 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.deleteRow.bind(<span class="keyword">this</span>, id)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 当你通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面。</span></span><br><span class="line"><span class="regexp">class Popper extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor () &#123;</span></span><br><span class="line"><span class="regexp">    super(...arguments)</span></span><br><span class="line"><span class="regexp">    this.state = &#123; name:'Hello world!' &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 你可以通过 bind 传入多个参数</span></span><br><span class="line"><span class="regexp">  preventPop (name, test, e) &#123;    /</span><span class="regexp">/事件对象 e 要放在最后</span></span><br><span class="line"><span class="regexp">    e.stopPropagation()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;Button </span></span><br><span class="line"><span class="regexp">    onClick=&#123;this.preventPop.bind(this, this.state.name, 'test')&#125;&gt;&lt;/</span>Button&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用匿名函数"><a href="#使用匿名函数" class="headerlink" title="使用匿名函数"></a>使用匿名函数</h4><blockquote><p>注意：在各小程序端，使用匿名函数，尤其是在 循环中 使用匿名函数，比使用 bind 进行事件传参占用更大的内存，速度也会更慢。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Popper</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>(...arguments)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">name</span>: <span class="string">'Hello world!'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">'test'</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Button onClick=&#123;(e) =&gt; &#123;</span><br><span class="line">        e.stopPropagation()</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          name</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.name&#125;</span><br><span class="line">      &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="柯里化传参"><a href="#柯里化传参" class="headerlink" title="柯里化传参"></a>柯里化传参</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function">(<span class="params">index</span>) =&gt;</span> <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      currentIndex: index</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; currentIndex &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &#123;<span class="comment">/* 调用 `this.handleClick(currentIndex)` 会返回一个函数，这个函数可以访问到 `currentIndex` 同时也能满足 `onClick` 的签名 */</span>&#125;</span><br><span class="line">      &lt;View onClick=&#123;<span class="keyword">this</span>.handleClick(currentIndex)&#125;&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br></pre></td></tr></table></figure><h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>在函数式组件中，事件传参可以传入事件的引用也可以传入匿名函数，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [c1, setC1] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [c2, setC2] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [c3, setC3] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increment = <span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有 useCallback 对应的 c1 或 c2 的值改变时，才会返回新的函数</span></span><br><span class="line">  <span class="keyword">const</span> increment1 = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setC1(increment), [c1]);</span><br><span class="line">  <span class="keyword">const</span> increment2 = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setC2(increment), [c2]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Text</span>&gt;</span> Counter 1 is &#123;c1&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Text</span>&gt;</span> Counter 2 is &#123;c2&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Text</span>&gt;</span> Counter 3 is &#123;c3&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Button onClick=&#123;increment1&#125;&gt;Increment Counter 1&lt;/Button&gt;</span><br><span class="line">      &lt;Button onClick=&#123;increment2&#125;&gt;Increment Counter 2&lt;/Button&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; setC3(increment)&#125;&gt;Increment Counter 3&lt;/Button&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任何组件的事件传递都要以-on-开头"><a href="#任何组件的事件传递都要以-on-开头" class="headerlink" title="任何组件的事件传递都要以 on 开头"></a>任何组件的事件传递都要以 on 开头</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在微信小程序中，可能你会看到像 bindTap 这样的用法，但在 Taro 中，事件参数(props)都以 on 开头:</span></span><br><span class="line"><span class="comment">// 错误 </span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">bindtap</span>=<span class="string">&#123;this.onTag&#125;</span> /&gt;</span></span></span><br><span class="line">const element2 = &lt;Input bindfocus=&#123;this.onFocus&#125; /&gt;</span><br><span class="line">const element3 = &lt;CustomElement animationEnd=&#123;this.props.onAnimationEnd&#125; /&gt;</span><br><span class="line"></span><br><span class="line">// 只要当 JSX 组件传入的参数是函数，参数名就必须以 on 开头：</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">const element = &lt;View onClick=&#123;this.onTag&#125; /&gt;</span><br><span class="line">const element2 = &lt;Input onFocus=&#123;this.onFocus&#125; /&gt;</span><br><span class="line">const element3 = &lt;CustomElement onAnimationEnd=&#123;this.props.onAnimationEnd&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>taroKey 适用于循环渲染原生小程序组件，赋予每个元素唯一确定标识，转换为小程序的 wx:key。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [...Array(<span class="number">100</span>).keys()] <span class="comment">// [0, 1, 2, ..., 98, 99]</span></span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// native component</span></span><br><span class="line">    &lt;g-list</span><br><span class="line">      taroKey=&#123;<span class="built_in">String</span>(number)&#125;</span><br><span class="line">      className=<span class="string">'g-list'</span></span><br><span class="line">    &gt;</span><br><span class="line">    我是第 &#123;number + <span class="number">1</span>&#125; 个数字</span><br><span class="line">    &lt;<span class="regexp">/g-list&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><p>元素的 key 在他的兄弟元素之间应该唯一</p><h4 id="与-React-的不同"><a href="#与-React-的不同" class="headerlink" title="与 React 的不同"></a>与 React 的不同</h4><blockquote><p>在 React 中，JSX 是会编译成普通的 JS 的执行，每一个 JSX 元素，其实会通过 createElement 函数创建成一个 JavaScript 对象（React Element），因此实际上你可以这样写代码 React 也是完全能渲染的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="keyword">this</span>.state.list.map(<span class="function"><span class="params">l</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (l.selected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;l.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).filter(React.isValidElement)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">this</span>.state.list.map(<span class="function"><span class="params">l</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (l.selected) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="string">'$$typeof'</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">      <span class="string">'props'</span>: &#123;</span><br><span class="line">        children: l.text</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'type'</span>: <span class="string">'li'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).filter(React.isValidElement)</span><br></pre></td></tr></table></figure><h3 id="函数式组件-1"><a href="#函数式组件-1" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>定义一个函数式组件非常简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个函数接受一个参数 props，并且返回的是一个 JSX 元素。这样的函数就是函数式组件。相对于的 ES6 Class 组件是：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类函数式组件"><a href="#类函数式组件" class="headerlink" title="类函数式组件"></a>类函数式组件</h3><blockquote><p>由于一个文件不能定义两个组件，但有时候我们需要组件内部的抽象组件，这时类函数式组件就是你想要答案。假设我们有一个 Class 组件，它包括了一个 Header 一个 Footer，我们可以这样定义：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomePage</span> <span class="keyword">extends</span> <span class="title">Taro</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  renderHeader () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; header &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>&#123;header&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  renderFooter (footer) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>&#123;footer&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.renderHeader()&#125;</span><br><span class="line">        &#123;...&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.renderFooter(<span class="string">'footer'</span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 renderHeader 或 renderFooter 函数中，我们可以访问类的 this，也可以传入不限量的参数，这类型的函数也可以调用无限次数。但这样的写法也存在一些限制：</p><ul><li>函数的命名必须以 render 开头，render 后的第一个字母需要大写</li><li>函数的参数不得传入 JSX 元素或 JSX 元素引用</li><li>函数不能递归地调用自身<blockquote><p>形如 renderHeader 这样的函数在小程序中会编译成 template，而小程序的 template 是无法做到递归调用自身的。当你有这样的需求时，可以新建两个一模一样的组件和文件：ComponentA 和 ComponentB，在 ComponentA 中调用 ComponentB，在 ComponentB 中调用 ComponnetA。</p></blockquote></li></ul><h3 id="闭包函数式组件"><a href="#闭包函数式组件" class="headerlink" title="闭包函数式组件"></a>闭包函数式组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span> (<span class="params">&#123; user &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = user.name</span><br><span class="line">  <span class="keyword">const</span> renderTitle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// renderTitle 每次都能获取到当前作用域 `name` 的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>Welcome, &#123;name&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &#123;<span class="comment">/* 重要人士我们要欢迎他三次 */</span> &#125;</span><br><span class="line">      &#123;renderTitle()&#125;</span><br><span class="line">      &#123;renderTitle()&#125;</span><br><span class="line">      &#123;renderTitle()&#125;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><blockquote><p>const MyContext = Taro.createContext(defaultValue)<br>创建一个 Context 对象。当 Taro 渲染一个订阅了这个 Context 对象的组件，这个组件会从最先渲染的 Provider 中读取到 Provider 的 value。<br>在 Taro 中，即便在框架层面也无法知道组件的树结构，因此 Taro 无法像 React 一样往父组件找离自己最近的 Provider。因此创建的 Context 最好只在一个地方使用。</p></blockquote><blockquote><p>&lt;MyContext.Provider value={/* 某个值 */}&gt;</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Taro</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="comment">/* 基于 MyContext 组件的值进行渲染 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyClass.contextType = MyContext;</span><br></pre></td></tr></table></figure><h4 id="context使用"><a href="#context使用" class="headerlink" title="context使用"></a>context使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter-context.ts</span></span><br><span class="line"><span class="keyword">import</span> Taro <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CounterContext = Taro.createContext(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UserContext = Taro.createContext(&#123;</span><br><span class="line">  name: <span class="string">'Guest'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="keyword">import</span> Taro, &#123; Component, Config, useContext &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; CounterContext,UserContext &#125; <span class="keyword">from</span> <span class="string">'./counter-context'</span></span><br><span class="line"><span class="keyword">import</span> &#123; View&#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// static contextType = CounterContext</span></span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// const value = this.context</span></span><br><span class="line">    <span class="comment">// const user = this.context</span></span><br><span class="line">    <span class="keyword">const</span> value =  useContext(CounterContext)</span><br><span class="line">    <span class="keyword">const</span> &#123;name&#125; =  useContext(UserContext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        Count: &#123;value&#125;</span><br><span class="line">        name:&#123;name&#125;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ counter.ts</span></span><br><span class="line"><span class="regexp">import Taro, &#123; Component, Config, useState &#125; from '@tarojs/</span>taro<span class="string">'</span></span><br><span class="line"><span class="string">import &#123; CounterContext,UserContext &#125;  from '</span>./counter-context<span class="string">'</span></span><br><span class="line"><span class="string">import Child  from '</span>./child<span class="string">'</span></span><br><span class="line"><span class="string">import &#123; View, Button&#125; from '</span>@tarojs/components<span class="string">'</span></span><br><span class="line"><span class="string">export default class ContextValue extends Component &#123;</span></span><br><span class="line"><span class="string">  gogogo()&#123;</span></span><br><span class="line"><span class="string">    console.log('</span>gogo<span class="string">');</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  render () &#123;</span></span><br><span class="line"><span class="string">    const [ count , setCount] = useState(0)</span></span><br><span class="line"><span class="string">    const [ val ] = useState(&#123;name:'</span>asd<span class="string">'&#125;)</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;CounterContext.Provider value=&#123;count&#125;&gt;</span></span><br><span class="line"><span class="string">        &lt;UserContext.Provider value=&#123;val&#125;&gt;</span></span><br><span class="line"><span class="string">        &lt;View className='</span>container<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;Child /&gt;</span></span><br><span class="line"><span class="string">          &lt;Button onClick=&#123;() =&gt; setCount(0)&#125;&gt;Reset&lt;/Button&gt;</span></span><br><span class="line"><span class="string">          &lt;Button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/Button&gt;</span></span><br><span class="line"><span class="string">          &lt;Button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/Button&gt;</span></span><br><span class="line"><span class="string">        &lt;/View&gt;</span></span><br><span class="line"><span class="string">        &lt;/UserContext.Provider&gt;</span></span><br><span class="line"><span class="string">      &lt;/CounterContext.Provider&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Children"><a href="#Children" class="headerlink" title="Children"></a>Children</h3><p>在我们设计组件时，有些组件通常不知道自己的子组件会有什么内容，例如 Sidebar 和 Dialog 这样的容器组件。</p><p>我们建议在这样的情况使用 this.props.children 来传递子元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View className=<span class="string">'dialog'</span>&gt;</span><br><span class="line">        &lt;View className=<span class="string">'header'</span>&gt;Welcome!<span class="xml"><span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">        &lt;View className=<span class="string">'body'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &lt;View className='footer'&gt;-- divider --&lt;/</span>View&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这样就能允许其它组件在 JSX 中嵌套任意子组件传递给 Dialog:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View className=&apos;container&apos;&gt;</span><br><span class="line">        &lt;Dialog&gt;</span><br><span class="line">          &lt;View className=&quot;dialog-message&quot;&gt;</span><br><span class="line">            Thank you for using Taro.</span><br><span class="line">          &lt;/View&gt;</span><br><span class="line">        &lt;/Dialog&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <Dialog /> JSX 标签内的任何内容都会作为它的子元素(Children)都会传递到它的组件。</p><p>注意事项:不要对 this.props.children 进行任何操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Taro 在小程序中实现这个功能使用的是小程序的 slot 功能,也就是说你可以把 this.props.children 理解为 slot 的语法糖，this.props.children 在 Taro 中并不是 React 的 ReactElement 对象，因此形如 this.props.children &amp;&amp; this.props.children、this.props.children[0] 在 Taro 中都是非法的。</span></span><br><span class="line"><span class="comment">// this.props.children 无法用 defaultProps 设置默认内容。由于小程序的限制，Taro 也无法知道组件的消费者是否传入内容，所以无法应用默认内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能把 this.props.children 分解为变量再使用。由于普通的 props 有一个确切的值，所以当你把它们分解为变量运行时可以处理，this.props.children 则不能这样操作，你必须显性地把 this.props.children 全部都写完整才能实现它的功能。</span></span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View className=<span class="string">'dialog'</span>&gt;</span><br><span class="line">        &lt;View className=<span class="string">'header'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.renderHeader&#125;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &lt;View className='body'&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>View&gt;</span><br><span class="line">        &lt;View className=<span class="string">'footer'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.renderFooter&#125;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View className=<span class="string">'container'</span>&gt;</span><br><span class="line">        &lt;Dialog</span><br><span class="line">          renderHeader=&#123;</span><br><span class="line">            &lt;View className=<span class="string">'welcome-message'</span>&gt;Welcome!<span class="xml"><span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">          &#125;</span><br><span class="line">          renderFooter=&#123;</span><br><span class="line">            &lt;Button className=<span class="string">'close'</span>&gt;Close&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          &lt;View className="dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">            Thank you for using Taro.</span></span><br><span class="line"><span class="regexp">          &lt;/</span>View&gt;</span><br><span class="line">        &lt;<span class="regexp">/Dialog&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有组合都必须用 render 开头，且遵守驼峰式命名法。和我们的事件规范以 on 开头一样，组件组合使用 render 开头。<br>组合只能传入单个 JSX 元素，不能传入其它任何类型。当你需要进行一些条件判断或复杂逻辑操作的时候，可以使用一个 Block 元素包裹住，然后在 Block 元素的里面填充其它复杂的逻辑。</p><h4 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h4><p>具有 render prop 的组件接受一个函数，该函数返回一个 Taro 元素并调用它而不是实现自己的渲染逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cat.js</span></span><br><span class="line"><span class="keyword">import</span> catImage <span class="keyword">from</span> <span class="string">'./cat.jpg'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Taro</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    mouse: &#123;</span><br><span class="line">      x: <span class="number">0</span>,</span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; mouse &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Image src=&#123;catImage&#125; style=&#123;&#123; <span class="attr">position</span>: <span class="string">'absolute'</span>, <span class="attr">left</span>: mouse.x, <span class="attr">top</span>: mouse.y &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mouse.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">Taro</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleMouseMove = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(event) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125;  = event.detail</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;&#123; <span class="attr">height</span>: <span class="string">'100%'</span> &#125;&#125; onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">          我们可以把 prop 当成一个函数，动态地调整渲染内容。</span></span><br><span class="line"><span class="comment">        */</span>&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.renderCat(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ MouseTracker.js</span></span><br><span class="line"><span class="regexp">class MouseTracker extends Taro.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;View&gt;</span></span><br><span class="line"><span class="regexp">        &lt;View&gt;点击鼠标!&lt;/</span>View&gt;</span><br><span class="line">        &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">          Mouse 如何渲染由 MouseTracker 的状态控制</span></span><br><span class="line"><span class="comment">        */</span>&#125;</span><br><span class="line">        &lt;Mouse renderCat=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Cat mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h3><h4 id="使用字符串创建-ref"><a href="#使用字符串创建-ref" class="headerlink" title="使用字符串创建 ref"></a>使用字符串创建 ref</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="comment">// 如果 ref 的是小程序原生组件，那只有在 didMount 生命周期之后才能通过</span></span><br><span class="line">    <span class="comment">// this.refs.input 访问到小程序原生组件</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'weapp'</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里 this.refs.input 访问的时候通过 `wx.createSeletorQuery` 取到的小程序原生组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里 this.refs.input 访问到的是 `@tarojs/components` 的 `Input` 组件实例</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">ref</span>=<span class="string">'input'</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="通过函数创建-ref"><a href="#通过函数创建-ref" class="headerlink" title="通过函数创建 ref"></a>通过函数创建 ref</h4><p>你也可以通过传递一个函数创建 ref, 在函数中被引用的组件会作为函数的第一个参数传递。如果是被引用的组件是自定义组件，那可以在任意的生命周期访问引用。</p><blockquote><p>不管在任何情况下，Taro 都推荐你使用函数的方式创建 ref。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  roar () &#123;</span><br><span class="line">    <span class="comment">// 会打印 `miao, miao, miao~`</span></span><br><span class="line">    <span class="keyword">this</span>.cat.miao()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  refCat = <span class="function">(<span class="params">node</span>) =&gt;</span> <span class="keyword">this</span>.cat = node <span class="comment">// `this.cat` 会变成 `Cat` 组件实例的引用</span></span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Cat</span> <span class="attr">ref</span>=<span class="string">&#123;this.refCat&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class Cat extends Component &#123;</span></span><br><span class="line"><span class="xml">  miao () &#123;</span></span><br><span class="line"><span class="xml">    console.log('miao, miao, miao~')</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  render () &#123;</span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="通过-createRef-创建-ref"><a href="#通过-createRef-创建-ref" class="headerlink" title="通过 createRef 创建 ref"></a>通过 createRef 创建 ref</h3><blockquote><p>Refs 还是使用 Taro.createRef() 创建的，并通过 ref 属性附加到 Taro 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</p></blockquote><blockquote><p>当 ref 被传递给 render 中的元素时，对该节点的引用可以在 ref 的 current 属性中被访问。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.cat = Taro.createRef()</span><br><span class="line"></span><br><span class="line">  roar () &#123;</span><br><span class="line">    <span class="comment">// 会打印 `miao, miao, miao~`</span></span><br><span class="line">    <span class="keyword">this</span>.cat.current.miao()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Cat</span> <span class="attr">ref</span>=<span class="string">&#123;this.cat&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class Cat extends Component &#123;</span></span><br><span class="line"><span class="xml">  miao () &#123;</span></span><br><span class="line"><span class="xml">    console.log('miao, miao, miao~')</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  render () &#123;</span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="跨平台开发"><a href="#跨平台开发" class="headerlink" title="跨平台开发"></a>跨平台开发</h3><p>内置环境变量<br>Taro 在编译时提供了一些内置的环境变量来帮助用户做一些特殊处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">process.env.TARO_ENV </span><br><span class="line"><span class="comment">//用于判断当前编译类型，目前有 weapp / swan / alipay / h5 / rn / tt / qq / quickapp 八个取值，可以通过这个变量来书写对应一些不同环境下的代码，在编译时会将不属于当前编译类型的代码去掉，只保留当前编译类型下的代码，例如想在微信小程序和 H5 端分别引用不同资源</span></span><br><span class="line"><span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'weapp'</span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'path/to/weapp/name'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'path/to/h5/name'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同时也可以在 JSX 中使用，决定不同端要加载的组件</span></span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &#123;process.env.TARO_ENV === <span class="string">'weapp'</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">ScrollViewWeapp</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">      &#123;process.env.TARO_ENV === 'h5' &amp;&amp; <span class="tag">&lt;<span class="name">ScrollViewH5</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一接口的多端文件"><a href="#统一接口的多端文件" class="headerlink" title="统一接口的多端文件"></a>统一接口的多端文件</h3><p>内置环境变量虽然可以解决大部分跨端的问题，但是会让代码中充斥着逻辑判断的代码，影响代码的可维护性，而且也让代码变得愈发丑陋，为了解决这种问题，自 1.2.17 开始，Taro 提供了另外一种跨端开发的方式作为补充。</p><p>开发者可以通过使用统一接口的多端文件，来解决跨端差异的功能。针对一项功能，如果多个端之间都有差异，那么开发者可以通过将文件修改成 原文件名 + 端类型 的命名形式，不同端的文件代码对外保持统一接口，而引用的时候仍然是 import 原文件名的文件，Taro 在编译时，会跟根据需要编译平台类型，将加载的文件变更为带有对应端类型文件名的文件，从而达到不同的端加载对应文件的目的。</p><p>端类型对应着 process.env.TARO_ENV 的值</p><p>通常有以下两种使用场景。</p><h4 id="多端组件"><a href="#多端组件" class="headerlink" title="多端组件"></a>多端组件</h4><p>假如有一个 Test 组件存在微信小程序、百度小程序和 H5 三个不同版本，那么就可以像如下组织代码</p><p>test.js 文件，这是 Test 组件默认的形式，编译到微信小程序、百度小程序和 H5 三端之外的端使用的版本</p><p>test.h5.js 文件，这是 Test 组件的 H5 版本</p><p>test.weapp.js 文件，这是 Test 组件的 微信小程序 版本</p><p>test.swan.js 文件，这是 Test 组件的 百度小程序 版本</p><p>test.qq.js 文件，这是 Test 组件的 QQ 小程序 版本</p><p>test.quickapp.js 文件，这是 Test 组件的 快应用 版本</p><p>四个文件，对外暴露的是统一的接口，它们接受一致的参数，只是内部有针对各自平台的代码实现</p><p>而我们使用 Test 组件的时候，引用的方式依然和之前保持一致，import 的是不带端类型的文件名，在编译的时候会自动识别并添加端类型后缀</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Test <span class="keyword">from</span> <span class="string">'../../components/test'</span></span><br><span class="line"></span><br><span class="line">&lt;Test argA=&#123;<span class="number">1</span>&#125; argA=&#123;<span class="number">2</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><h4 id="多端脚本逻辑"><a href="#多端脚本逻辑" class="headerlink" title="多端脚本逻辑"></a>多端脚本逻辑</h4><p>与多端组件类似，假如有需要针对不同的端写不同的脚本逻辑代码，我们也可以类似的进行处理，遵守的唯一原则就是多端文件对外的接口保持一致。</p><p>例如微信小程序上使用 Taro.setNavigationBarTitle 来设置页面标题，H5 使用 document.title，那么可以封装一个 setTitle 方法来抹平两个平台的差异。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加 set_title.h5.js，代码如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span> (<span class="params">title</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.title = title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加 set_title.weapp.js，代码如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Taro <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span> (<span class="params">title</span>) </span>&#123;</span><br><span class="line">  Taro.setNavigationBarTitle(&#123;</span><br><span class="line">    title</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">import</span> setTitle <span class="keyword">from</span> <span class="string">'../utils/set_title'</span></span><br><span class="line"></span><br><span class="line">setTitle(<span class="string">'页面标题'</span>)</span><br></pre></td></tr></table></figure><p>使用要点</p><ul><li>不同端的对应文件一定要统一接口，统一调用方式</li><li>最好有一个平台无关的默认文件，这样在使用 ts 的时候也不会出现报错</li><li>引用文件的时候，只需要写默认文件名，不用带文件后缀</li></ul><h3 id="app-js-中使用不同的-pages"><a href="#app-js-中使用不同的-pages" class="headerlink" title="app.js 中使用不同的 pages"></a>app.js 中使用不同的 pages</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">config: Config = </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"pages"</span>: preval<span class="string">`</span></span><br><span class="line"><span class="string">    module.exports=(function() &#123;</span></span><br><span class="line"><span class="string">      if (process.env.TARO_ENV === 'weapp') &#123;</span></span><br><span class="line"><span class="string">        return [</span></span><br><span class="line"><span class="string">          '/pages/index/index'</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      if (process.env.TARO_ENV === 'swan') &#123;</span></span><br><span class="line"><span class="string">        return [</span></span><br><span class="line"><span class="string">          '/pages/indexswan/indexswan'</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;)()</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多端同步调试"><a href="#多端同步调试" class="headerlink" title="多端同步调试"></a>多端同步调试</h3><p>从 1.3.5 版本开始，可以在 dist 目录下创建一个与编译的目标平台名同名的目录，并将结果放在这个目录下，例如编译到微信小程序，最终结果是在 dist/weapp 目录下，这样做的好处是，各个平台使用独立的目录互不影响，从而达到多端同步调试的目的，在 config/index.js 配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputRoot: <span class="string">`dist/<span class="subst">$&#123;process.env.TARO_ENV&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>多端同步调试需要在终端工具中打开多个 Tab 来同时执行 taro 命令进行同步调试，如下图，编译成微信小程序和支付宝小程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Item1:终端窗口1</span></span><br><span class="line">taro build --type alipay --watch</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterm2：终端窗口2</span></span><br><span class="line">taro build --type weapp --watch</span><br></pre></td></tr></table></figure><h3 id="小程序原生作用域获取"><a href="#小程序原生作用域获取" class="headerlink" title="小程序原生作用域获取"></a>小程序原生作用域获取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Taro 的页面和组件类中，this 指向的是 Taro 页面或组件的实例，例如</span></span><br><span class="line"><span class="keyword">import</span> Taro, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; View &#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    data: []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      checked: props.checked</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// this -&gt; 组件 Menu 的实例</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>但是一般我们需要获取 Taro 的页面和组件所对应的小程序原生页面和组件的实例，这个时候我们可以通过 this.$scope 就能访问到它们。</p><p>所以当调用一些 API 需要传入小程序的页面或者组件实例时，可以直接传入 this.$scope，例如 Taro.createCanvasContext(canvasId, this) 这个 API，第二个参数就是自定义组件实例 this，在 Taro 中就可以如下使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Taro.createCanvasContext(canvasId, <span class="keyword">this</span>.$scope)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Taro&quot;&gt;&lt;a href=&quot;#Taro&quot; class=&quot;headerlink&quot; title=&quot;Taro&quot;&gt;&lt;/a&gt;Taro&lt;/h2&gt;&lt;h3 id=&quot;环境要求&quot;&gt;&lt;a href=&quot;#环境要求&quot; class=&quot;headerlink&quot; title=&quot;环境要求&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/tags/react/"/>
    
      <category term="Taro" scheme="https://jacob1811.github.io/blog/tags/Taro/"/>
    
  </entry>
  
  <entry>
    <title>react生命周期</title>
    <link href="https://jacob1811.github.io/blog/2019/11/27/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://jacob1811.github.io/blog/2019/11/27/react生命周期/</id>
    <published>2019-11-27T07:35:36.000Z</published>
    <updated>2019-11-27T07:39:58.874Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5cfe5b85e51d45775a7002f1" target="_blank" rel="noopener">react生命周期</a></p><p><a href="http://git.baijiahulian.com/chuyonghui/fe-react-life" target="_blank" rel="noopener">项目代码demo</a></p><h3 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h3><blockquote><p>React 不是真正的DOM，而是会生成虚拟DOM，虚拟DOM会经历一个创建，更新，删除的过程；</p></blockquote><h4 id="生命周期函数："><a href="#生命周期函数：" class="headerlink" title="生命周期函数："></a>生命周期函数：</h4><h3 id="装配："><a href="#装配：" class="headerlink" title="装配："></a>装配：</h3><ul><li>constructor</li><li>static getDerivedStateFromProps</li><li>componentWillMount/UNSAFF_componentWillMount</li><li>render</li><li>componentDidMount</li></ul><h3 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h3><ul><li>componentWillReceiveProps/UNSAFF_componentWillReceiveProps</li><li>static getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate/UNSAFF_componentWillUpdate</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><ul><li>componentWillUnmount</li></ul><h3 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h3><blockquote><p>父组件更新会导致子组件更新</p></blockquote><blockquote><p>更新三种方式：父组件更新；setState;forceUpdate</p></blockquote><h3 id="componentWillMount-工作"><a href="#componentWillMount-工作" class="headerlink" title="componentWillMount 工作"></a>componentWillMount 工作</h3><blockquote><p>因为执行在render之前，所以在这里使用setState不会 re-render(重新渲染)<br>server render(服务端渲染)唯一使用的 hook (钩子)<br>通常construtor代替</p></blockquote><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><h3 id="getSnapshotBeforeUpdate警告"><a href="#getSnapshotBeforeUpdate警告" class="headerlink" title="getSnapshotBeforeUpdate警告"></a>getSnapshotBeforeUpdate警告</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6n1ppwo3aj327o0ccgpo.jpg" alt=""></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6n1tqioqjj313u0u0ad9.jpg" alt=""></p><p>forceUpdate 强制更新不再询问shouldComponentUpdate生命周期</p><p>componentWillMount/componentWillUpdate  放置ajax</p><h3 id="shouldComponentUpdate-工作图"><a href="#shouldComponentUpdate-工作图" class="headerlink" title="shouldComponentUpdate 工作图"></a>shouldComponentUpdate 工作图</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ok1pae8jj31dq0p6mzq.jpg" alt=""></p><p><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">React.PureComponent</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******  优化前  ********/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'setting state'</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">unseen</span>: <span class="string">"does not display"</span> &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'render called'</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******  优化后  ********/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'setting state'</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">unseen</span>: <span class="string">"does not display"</span> &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">        <span class="keyword">const</span> differentTitle = <span class="keyword">this</span>.props.title !== nextProps.title;</span><br><span class="line">        <span class="keyword">const</span> differentDone = <span class="keyword">this</span>.props.done !== nextProps.done</span><br><span class="line">        <span class="keyword">return</span> differentTitle || differentDone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'render called'</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期中的4个需要接收参数函数"><a href="#生命周期中的4个需要接收参数函数" class="headerlink" title="生命周期中的4个需要接收参数函数"></a>生命周期中的4个需要接收参数函数</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ok882sgbj31b20iqdjc.jpg" alt=""></p><h3 id="react17版本后，静态方法替换三个will生命周期"><a href="#react17版本后，静态方法替换三个will生命周期" class="headerlink" title="react17版本后，静态方法替换三个will生命周期"></a>react17版本后，静态方法替换三个will生命周期</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6oknh5v4ej31o40smdjr.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6oky255qnj31gu0o4q5w.jpg" alt=""></p><blockquote><p>静态方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.a = <span class="number">2</span></span><br><span class="line">obj.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'obj.b'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj2</span> </span>&#123;&#125;</span><br><span class="line">Obj2.a = <span class="number">111</span></span><br><span class="line">Obj2.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'obj2.b'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 static 可以添加静态方法，静态属性不可以</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> b()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'static.b'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Obj2.a = <span class="number">111</span></span><br></pre></td></tr></table></figure><h3 id="新生命周期"><a href="#新生命周期" class="headerlink" title="新生命周期"></a>新生命周期</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6okw4svn3j31b80u0n18.jpg" alt=""></p><h3 id="快照-getSnapshotBeforeUpdate"><a href="#快照-getSnapshotBeforeUpdate" class="headerlink" title="快照 getSnapshotBeforeUpdate"></a>快照 getSnapshotBeforeUpdate</h3><blockquote><p>更改DOM之前会获取快照,这个方法返回的return将会传递给componentDidUpdate</p></blockquote><p><a href="https://blog.csdn.net/wust_cyl/article/details/84306393" target="_blank" rel="noopener">getSnapshotBeforeUpdate应用</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState)=&gt;(&#123;</span><br><span class="line">  count:prevState.count+1</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><ul><li>key 对list 优化</li><li>对象 重绘</li><li>匿名函数</li><li>根节点变换</li><li>浅比较 PureComponent </li></ul><p>参考链接<br><a href="https://blog.csdn.net/u014744118/article/details/88925722" target="_blank" rel="noopener">React16性能优化-实战</a></p><p><a href="https://blog.csdn.net/weixin_41902031/article/details/80353134" target="_blank" rel="noopener">React常用性能优化方式整理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cfe5b85e51d45775a7002f1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;react生命周期&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git.baijiah
      
    
    </summary>
    
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-hooks</title>
    <link href="https://jacob1811.github.io/blog/2019/11/25/react-hooks/"/>
    <id>https://jacob1811.github.io/blog/2019/11/25/react-hooks/</id>
    <published>2019-11-25T03:39:05.000Z</published>
    <updated>2019-12-27T07:04:35.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="what-this-hooks"><a href="#what-this-hooks" class="headerlink" title="what this hooks"></a>what this hooks</h3><p> 2018年底，FaceBook的React小组推出。 <code>React Hooks</code>就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理<code>state</code>，有<code>Hooks</code>可以不再使用类的形式定义组件了。这时候你的认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ReactHooksDemo</span><br><span class="line">cd ReactHooksDemo</span><br><span class="line">create-react-app demo01</span><br></pre></td></tr></table></figure><p>只留/src/index.js文件，然后把里边的代码删减成下面的样子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><p>React Hooks 编写形式对比</p><blockquote><p>写一个最简单的有状体组件，点我们点击按钮时，点击数量不断增加</p></blockquote><p>原始写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>:<span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;原始：You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.addCount.bind(this)&#125;&gt;Chlick me&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  addCount()&#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;count:this.state.count+1&#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>hooks写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;hooks:You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Example;</span></span><br></pre></td></tr></table></figure><p>再来个受控组件例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">从这两个程序的对比上可以看出Hooks本质上就是一类特殊的函数，他们可以为你的函数型组件（function component）注入一些特殊的功能。这听起来有点像以前React中的`</span><span class="string">``</span>Mixins<span class="string">``</span><span class="string">`差不多哦。其实是由很多不同，hooks的目的就是让你不再写class，让function一统江湖。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## useState 的介绍和多状态声明</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;  useState 是react自带的一个hook函数，它的作用是用来声明状态变量。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">那我们从三个方面来看useState的用法，分别是声明、读取、使用（修改）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 声明</span></span><br><span class="line"><span class="string">解构写法</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>编译出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> _useState = userState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> count = _useState[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> setCount = _useState[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>useState</code>这个函数接收的参数是状态的初始值(Initial state)，它返回一个数组，这个数组的第0位是当前的状态值，第1位是可以改变状态值的方法函数。 所以上面的代码的意思就是声明了一个状态变量为<code>count</code>，并把它的初始值设为0，同时提供了一个可以改变<code>count</code>的状态值的方法函数。</p></blockquote><h5 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><p>读取是很简单的。只要使用{count}就可以，因为这时候的count就是JS里的一个变量，想在JSX中使用，值用加上{}就可以</p><h5 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;()=&gt;&#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;click me&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>直接调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给React,他会重新渲染组件。React自动帮助我们记忆了组件的上一次状态值，但是这种记忆也给我们带来了一点小麻烦，但是这种麻烦你可以看成规则，只要准守规则，就可以愉快的进行编码。</p><h5 id="多状态声明的注意事项"><a href="#多状态声明的注意事项" class="headerlink" title="多状态声明的注意事项"></a>多状态声明的注意事项</h5><p>比如现在我们要声明多个状态，有年龄（age）、性别(sex)和工作(work)。代码可以这么写.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ age , setAge ] = useState(<span class="number">18</span>)</span><br><span class="line">    <span class="keyword">const</span> [ sex , setSex ] = useState(<span class="string">'男'</span>)</span><br><span class="line">    <span class="keyword">const</span> [ work , setWork ] = useState(<span class="string">'前端程序员'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;JSPang 今年:&#123;age&#125;岁&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;性别:&#123;sex&#125;&lt;/</span>p&gt;</span><br><span class="line">            &lt;p&gt;工作是:&#123;work&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            </span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example2;</span><br></pre></td></tr></table></figure><p>疑问：在使用useState的时候只赋了初始值，并没有绑定任何的key,那React是怎么保证这三个useState找到它自己对应的state呢？</p><h5 id="答案是：React是根据useState出现的顺序来确定的"><a href="#答案是：React是根据useState出现的顺序来确定的" class="headerlink" title="答案是：React是根据useState出现的顺序来确定的"></a>答案是：React是根据useState出现的顺序来确定的</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> showSex = <span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ age , setAge ] = useState(<span class="number">18</span>)</span><br><span class="line">    <span class="keyword">if</span>(showSex)&#123;</span><br><span class="line">        <span class="keyword">const</span> [ sex , setSex ] = useState(<span class="string">'男'</span>)</span><br><span class="line">        showSex=<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> [ work , setWork ] = useState(<span class="string">'前端程序员'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;JSPang 今年:&#123;age&#125;岁&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;性别:&#123;sex&#125;&lt;/</span>p&gt;</span><br><span class="line">            &lt;p&gt;工作是:&#123;work&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            </span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example2;</span><br></pre></td></tr></table></figure><p>这时候控制台就会直接给我们报错，错误如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./src/App.js</span><br><span class="line">  Line <span class="number">7</span>:<span class="number">34</span>:   React Hook <span class="string">"useState"</span> is called conditionally. React Hooks must be called <span class="keyword">in</span> the exact same order <span class="keyword">in</span> every component render  react-hooks/rules-<span class="keyword">of</span>-hooks</span><br><span class="line">  Line <span class="number">15</span>:<span class="number">20</span>:  <span class="string">'sex'</span> is not defined</span><br></pre></td></tr></table></figure><p>意思就是useState不能在if…else…这样的条件语句中进行调用，必须要按照相同的顺序进行渲染。如果你还是不理解，你可以记住这样一句话就可以了：就是<code>React Hooks不能出现在条件判断语句中，因为它必须有完全一样的渲染顺序</code>。</p><h4 id="useEffect代替常用生命周期函数"><a href="#useEffect代替常用生命周期函数" class="headerlink" title="useEffect代替常用生命周期函数"></a>useEffect代替常用生命周期函数</h4><p>在用Class制作组件时，经常会用生命周期函数，来处理一些额外的事情（副作用：和函数业务主逻辑关联不大，特定时间或事件中执行的动作，比如Ajax请求后端数据，添加登录监听和取消登录，手动修改DOM等等）。<br>在React Hooks中也需要这样类似的生命周期函数，比如在每次状态（State）更新时执行，它为我们准备了<code>useEffect</code>。</p><h5 id="用Class的方式为计数器增加生命周期函数"><a href="#用Class的方式为计数器增加生命周期函数" class="headerlink" title="用Class的方式为计数器增加生命周期函数"></a>用Class的方式为计数器增加生命周期函数</h5><p>为了让你更好的理解useEffect的使用，先用原始的方式把计数器的Demo增加两个生命周期函数componentDidMount和componentDidUpdate。分别在组件第一次渲染后在浏览器控制台打印出计数器结果和在每次计数器状态发生变化后打印出结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example3</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>:<span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`ComponentDidMount=&gt;You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`componentDidUpdate=&gt;You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123; </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.addCount.bind(this)&#125;&gt;Chlick me&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    addCount()&#123;</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;count:this.state.count+1&#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">export default Example3;</span></span><br></pre></td></tr></table></figure><h5 id="用useEffect函数来代替生命周期函数"><a href="#用useEffect函数来代替生命周期函数" class="headerlink" title="用useEffect函数来代替生命周期函数"></a>用useEffect函数来代替生命周期函数</h5><p>先引入useEffect</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//---关键代码---------start-------</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`useEffect=&gt;You clicked <span class="subst">$&#123;count&#125;</span> times`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//---关键代码---------end-------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Example;</span></span><br></pre></td></tr></table></figure><p>那这段代码逻辑是什么？我们梳理一下:首先，我们生命了一个状态变量count,将它的初始值设为0，然后我们告诉react，我们的这个组件有一个副作用。给<code>useEffecthook</code>传了一个匿名函数，这个匿名函数就是我们的副作用。在这里我们打印了一句话，当然你也可以手动的去修改一个DOM元素。当React要渲染组件时，它会记住用到的副作用，然后执行一次。等Reat更新了State状态时，它再一词执行定义的副作用函数。</p><h5 id="useEffect两个注意点"><a href="#useEffect两个注意点" class="headerlink" title="useEffect两个注意点"></a>useEffect两个注意点</h5><ol><li>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(<code>componentDidMonut</code>)和更新导致的重新渲染(<code>componentDidUpdate</code>)。</li><li>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时<code>异步</code>执行的，而<code>componentDidMonut</code>和<code>componentDidUpdate</code>中的代码都是<code>同步</code>执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。</li></ol><h4 id="useEffect-实现-componentWillUnmount生命周期函数"><a href="#useEffect-实现-componentWillUnmount生命周期函数" class="headerlink" title="useEffect 实现 componentWillUnmount生命周期函数"></a>useEffect 实现 componentWillUnmount生命周期函数</h4><p>在组件中经常用到componentWillUnmount生命周期函数（组件将要被卸载时执行）。比如我们的定时器要清空，避免发生内存泄漏;比如登录状态要取消掉，避免下次进入信息出错。所以这个生命周期函数也是必不可少的，这节课就来用useEffect来实现这个生命周期函数,并讲解一下useEffect容易踩的坑。</p><h5 id="useEffect解绑副作用"><a href="#useEffect解绑副作用" class="headerlink" title="useEffect解绑副作用"></a>useEffect解绑副作用</h5><p>学习React Hooks 时，我们要改掉生命周期函数的概念（人往往有先入为主的毛病，所以很难改掉），因为Hooks叫它副作用，所以componentWillUnmount也可以理解成解绑副作用。这里为了演示用useEffect来实现类似componentWillUnmount效果，先安装React-Router路由,进入项目根本录，使用npm进行安装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-router-dom</span><br></pre></td></tr></table></figure><p>然后打开Example4.js文件，进行改写代码，先引入对应的React-Router组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span></span><br></pre></td></tr></table></figure><p>编写两个新组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>List-Page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这两个组件后，接下来可以编写路由配置，在以前的计数器代码中直接增加就可以了。<br>然后到浏览器中查看一下，看看组件和路由是否可用。如果可用，我们现在可以调整useEffect了。在两个新组件中分别加入useEffect()函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'useEffect=&gt;老弟，你来了！Index页面'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'useEffect=&gt;老弟，你来了！List页面'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>List-Page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们点击Link进入任何一个组件，在浏览器中都会打印出对应的一段话。这时候可以用返回一个函数的形式进行解绑，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'useEffect=&gt;老弟你来了！Index页面'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'老弟，你走了!Index页面'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这时候你在浏览器中预览，我们仿佛实现了componentWillUnmount方法。但这只是好像实现了，当点击计数器按钮时，你会发现老弟，你走了!Index页面，也出现了。这到底是怎么回事那？其实每次状态发生变化，useEffect都进行了解绑。</p><h5 id="useEffect的第二个参数"><a href="#useEffect的第二个参数" class="headerlink" title="useEffect的第二个参数"></a>useEffect的第二个参数</h5><p>那到底要如何实现类似componentWillUnmount的效果那?这就需要请出useEffect的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组[]时，就是当组件将被销毁时才进行解绑，这也就实现了componentWillUnmount的生命周期函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'useEffect=&gt;老弟你来了！Index页面'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'老弟，你走了!Index页面'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更加深入了解第二个参数的作用，把计数器的代码也加上useEffect和解绑方法，并加入第二个参数为空数组。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`useEffect=&gt;You clicked <span class="subst">$&#123;count&#125;</span> times`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'===================='</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt; <span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">                    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/list/"</span>&gt;</span>列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">                &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Route path="/</span><span class="string">" exact component=&#123;Index&#125; /&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/list/<span class="string">" component=&#123;List&#125; /&gt;</span></span><br><span class="line"><span class="string">            &lt;/Router&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候的代码是不能执行解绑副作用函数的。但是如果我们想每次count发生变化，我们都进行解绑，只需要在第二个参数的数组里加入count变量就可以了。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`useEffect=&gt;You clicked <span class="subst">$&#123;count&#125;</span> times`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'===================='</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[count])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt; <span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">                    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/list/"</span>&gt;</span>列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">                &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Route path="/</span><span class="string">" exact component=&#123;Index&#125; /&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/list/<span class="string">" component=&#123;List&#125; /&gt;</span></span><br><span class="line"><span class="string">            &lt;/Router&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候只要count状态发生变化，都会执行解绑副作用函数，浏览器的控制台也就打印出了一串=================。</p><h4 id="useContext-让父子组件传值更简单"><a href="#useContext-让父子组件传值更简单" class="headerlink" title="useContext 让父子组件传值更简单"></a>useContext 让父子组件传值更简单</h4><p>在用类声明组件时，父子组件的传值是通过组件属性和<code>props</code>进行的，那现在使用方法(Function)来声明组件，已经没有了<code>constructor</code>构造函数也就没有了props的接收，那父子组件的传值就成了一个问题。React Hooks 为我们准备了<code>useContext</code>。这节课就学习一下useContext，它可以帮助我们跨越组件层级直接传递变量，实现共享。需要注意的是<code>useContext</code>和<code>redux</code>的作用是不同的，一个解决的是组件之间值传递的问题，一个是应用中统一管理状态的问题，但通过和useReducer的配合使用，可以实现类似Redux的作用。</p><blockquote><p>Context的作用就是对它所包含的组件树提供全局共享数据的一种技术。</p></blockquote><h5 id="createContext-函数创建context"><a href="#createContext-函数创建context" class="headerlink" title="createContext 函数创建context"></a>createContext 函数创建context</h5><p>使用计数器代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState  &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example6</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Example6;</span></span><br></pre></td></tr></table></figure><p>引入createContext函数，并使用得到一个组件，然后在return方法中进行使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="comment">//===关键代码</span></span><br><span class="line"><span class="keyword">const</span> CountContext = createContext()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example6</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line">        &#123;<span class="comment">/*======关键代码 */</span>&#125;</span><br><span class="line">        &lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class="line">        &lt;<span class="regexp">/CountContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example6;</span><br></pre></td></tr></table></figure><p>这段代码就相当于把count变量允许跨层级实现传递和使用了（也就是实现了上下文），当父组件的count变量发生变化时，子组件也会发生变化。接下来我们就看看一个React Hooks的组件如何接收到这个变量。</p><h5 id="useContext-接收上下文变量"><a href="#useContext-接收上下文变量" class="headerlink" title="useContext 接收上下文变量"></a>useContext 接收上下文变量</h5><p>已经有了上下文变量，剩下的就时如何接收了，接收这个直接使用useContext就可以，但是在使用前需要新进行引入useContext（不引入是没办法使用的）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , createContext , useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure><p>引入后写一个Counter组件，只是显示上下文中的count变量代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useContext(CountContext)  <span class="comment">//一句话就可以得到count</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class="line">    &lt;Counter /&gt;</span><br><span class="line">&lt;<span class="regexp">/CountContext.Provider&gt;</span></span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , createContext ,useContext&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="comment">//===关键代码</span></span><br><span class="line"><span class="keyword">const</span> CountContext = createContext()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useContext(CountContext)  <span class="comment">//一句话就可以得到count</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example6</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line">        &#123;<span class="comment">/*======关键代码 */</span>&#125;</span><br><span class="line">        &lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class="line">            &lt;Counter /&gt;</span><br><span class="line">        &lt;<span class="regexp">/CountContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example6;</span><br></pre></td></tr></table></figure><h4 id="useReducer介绍和简单使用"><a href="#useReducer介绍和简单使用" class="headerlink" title=":useReducer介绍和简单使用"></a>:useReducer介绍和简单使用</h4><h6 id="reducer到底是什么？"><a href="#reducer到底是什么？" class="headerlink" title="reducer到底是什么？"></a>reducer到底是什么？</h6><p>为了更好的理解useReducer，所以先要了解JavaScript里的Redcuer是什么。它的兴起是从Redux广泛使用开始的，但不仅仅存在Redux中，可以使用冈的JavaScript来完成Reducer操作。那reducer其实就是一个函数，这个函数接收两个参数，一个是状态，一个用来控制业务逻辑的判断参数。我们举一个最简单的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'sub'</span>:</span><br><span class="line">            <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是Reducer，你主要理解的就是这种形式和两个参数的作用，一个参数是状态，一个参数是如何控制状态。</p><h5 id="useReducer的使用"><a href="#useReducer的使用" class="headerlink" title="useReducer的使用"></a>useReducer的使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example7</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , dispatch ] =useReducer(<span class="function">(<span class="params">state,action</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(action)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">                <span class="keyword">return</span> state+<span class="number">1</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'sub'</span>:</span><br><span class="line">                <span class="keyword">return</span> state<span class="number">-1</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">           &lt;h2&gt;现在的分数是&#123;count&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">           &lt;button onClick=&#123;()=&gt;dispatch('add')&#125;&gt;Increment&lt;/</span>button&gt;</span><br><span class="line">           &lt;button onClick=&#123;()=&gt;dispatch(<span class="string">'sub'</span>)&#125;&gt;Decrement&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">       &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example7</span><br></pre></td></tr></table></figure><h4 id="useReducer代替Redux小案例-1"><a href="#useReducer代替Redux小案例-1" class="headerlink" title="useReducer代替Redux小案例-1"></a>useReducer代替Redux小案例-1</h4><h5 id="理论上的可行性"><a href="#理论上的可行性" class="headerlink" title="理论上的可行性"></a>理论上的可行性</h5><p><code>useContext</code>：(状态共享)可访问全局状态，避免一层层的传递状态。这符合Redux其中的一项规则，就是状态全局化，并能统一管理。</p><p><code>useReducer</code>：(控制业务逻辑)通过action的传递，更新复杂逻辑的状态，主要是可以实现类似Redux中的Reducer部分，实现业务逻辑的可行性。</p><h5 id="编写基本UI组件"><a href="#编写基本UI组件" class="headerlink" title="编写基本UI组件"></a>编写基本UI组件</h5><p>src/reducerPage/showArea.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShowArea</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>'<span class="attr">blue</span>'&#125;&#125;&gt;</span>字体颜色为blue<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ShowArea</span><br></pre></td></tr></table></figure><p>src/reducerPage/Buttons.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Buttons</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button&gt;红色&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button&gt;黄色&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Buttons</span></span><br></pre></td></tr></table></figure><p>src/reducerPage/reducerPage.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ShowArea <span class="keyword">from</span> <span class="string">'./ShowArea'</span>;</span><br><span class="line"><span class="keyword">import</span> Buttons <span class="keyword">from</span> <span class="string">'./Buttons'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReducerPage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">                &lt;ShowArea /&gt;</span><br><span class="line">                &lt;Buttons /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default ReducerPage</span></span><br></pre></td></tr></table></figure><p>index 使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> ReducerPage <span class="keyword">from</span> <span class="string">'./ReducerPage/ReducerPage'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">ReducerPage</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><h5 id="编写颜色共享组件color-js"><a href="#编写颜色共享组件color-js" class="headerlink" title="编写颜色共享组件color.js"></a>编写颜色共享组件color.js</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ColorContext = createContext(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Color = <span class="function"><span class="params">props</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ColorContext.Provider value=&#123;&#123;<span class="attr">color</span>:<span class="string">"blue"</span>&#125;&#125;&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/ColorContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>代码中引入了createContext用来创建共享上下文ColorContext组件，然后我们要用{props.children}来显示对应的子组件。详细解释我在视频中讲解吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ShowArea <span class="keyword">from</span> <span class="string">'./ShowArea'</span>;</span><br><span class="line"><span class="keyword">import</span> Buttons <span class="keyword">from</span> <span class="string">'./Buttons'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Color &#125; <span class="keyword">from</span> <span class="string">'./color'</span>;   <span class="comment">//引入Color组件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReducerPage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Color&gt;</span><br><span class="line">                &lt;ShowArea /&gt;</span><br><span class="line">                &lt;Buttons /&gt;</span><br><span class="line">            &lt;<span class="regexp">/Color&gt;</span></span><br><span class="line"><span class="regexp">            </span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReducerPage</span><br></pre></td></tr></table></figure><p>然后再改写showArea.js文件，我们会引入useContext和在color.js中声明的ColorContext，让组件可以接收全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React , &#123; useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ColorContext &#125; <span class="keyword">from</span> <span class="string">'./color'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShowArea</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;color&#125; = useContext(ColorContext)</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:color&#125;&#125;</span>&gt;</span>字体颜色为&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ShowArea</span><br></pre></td></tr></table></figure><p>这时候就通过useContext实现了状态的共享，可以到浏览器中看一下效果。然后我们下节课再实现复杂逻辑状态的变化。</p><h4 id="useReducer代替Redux小案例-2"><a href="#useReducer代替Redux小案例-2" class="headerlink" title="useReducer代替Redux小案例-2"></a>useReducer代替Redux小案例-2</h4><h5 id="在color-js中添加Reducer"><a href="#在color-js中添加Reducer" class="headerlink" title="在color.js中添加Reducer"></a>在color.js中添加Reducer</h5><p>颜色（state）管理的代码我们都放在了color.js中，所以在文件里添加一个reducer，用于处理颜色更新的逻辑。先声明一个reducer的函数，它就是JavaScript中的普通函数，在讲useReducer的时候已经详细讲过了。有了reducer后，在Color组件里使用useReducer,这样Color组件就有了那个共享状态和处理业务逻辑的能力，跟以前使用的Redux几乎一样了。之后修改一下共享状态。我们来看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; createContext,useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ColorContext = createContext(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UPDATE_COLOR = <span class="string">"UPDATE_COLOR"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer= <span class="function">(<span class="params">state,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> UPDATE_COLOR:</span><br><span class="line">            <span class="keyword">return</span> action.color</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Color = <span class="function"><span class="params">props</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [color,dispatch]=useReducer(reducer,<span class="string">'blue'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ColorContext.Provider value=&#123;&#123;color,dispatch&#125;&#125;&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/ColorContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>注意，这时候我们共享出去的状态变成了color和dispatch,如果不共享出去dispatch，你是没办法完成按钮的相应事件的。</p><h5 id="通过dispatch修改状态"><a href="#通过dispatch修改状态" class="headerlink" title="通过dispatch修改状态"></a>通过dispatch修改状态</h5><p>目前程序已经有了处理共享状态的业务逻辑能力，接下来就可以在buttons.js使用dispatch来完成按钮的相应操作了。先引入useContext、ColorContext和UPDATE_COLOR，然后写onClick事件就可以了。代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React ,&#123;useContext&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ColorContext,UPDATE_COLOR&#125; <span class="keyword">from</span> <span class="string">'./color'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Buttons</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch &#125; = useContext(ColorContext)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;()=&gt;&#123;dispatch(&#123;<span class="attr">type</span>:UPDATE_COLOR,<span class="attr">color</span>:<span class="string">"red"</span>&#125;)&#125;&#125;&gt;红色&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;dispatch(&#123;type:UPDATE_COLOR,color:"yellow"&#125;)&#125;&#125;&gt;黄色&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Buttons</span></span><br></pre></td></tr></table></figure><p>这样代码就编写完成了，用useContext和useReducer实现了Redux的效果</p><h4 id="useMemo优化React-Hooks程序性能"><a href="#useMemo优化React-Hooks程序性能" class="headerlink" title="useMemo优化React Hooks程序性能"></a>useMemo优化React Hooks程序性能</h4><p>useMemo主要用来解决使用React hooks产生的无用渲染的性能问题。使用function的形式来声明组件，失去了shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React , &#123;useState,useMemo&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example7</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [xiaohong , setXiaohong] = useState(<span class="string">'小红待客状态'</span>)</span><br><span class="line">    <span class="keyword">const</span> [zhiling , setZhiling] = useState(<span class="string">'志玲待客状态'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;button onClick=&#123;()=&gt;&#123;setXiaohong(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())&#125;&#125;&gt;小红&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setZhiling(new Date().getTime()+',志玲向我们走来了')&#125;&#125;&gt;志玲&lt;/</span>button&gt;</span><br><span class="line">            &lt;ChildComponent name=&#123;xiaohong&#125;&gt;&#123;zhiling&#125;&lt;<span class="regexp">/ChildComponent&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件调用了子组件，子组件我们输出两个姑娘的状态，显示在界面上。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildComponent</span>(<span class="params">&#123;name,children&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeXiaohong</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'她来了，她来了。小红向我们走来了'</span>)</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">',小红向我们走来了'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> actionXiaohong = changeXiaohong(name)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;&#123;actionXiaohong&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;&#123;children&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候你会发现在浏览器中点击志玲按钮，小红对应的方法都会执行，结果虽然没变，但是每次都执行，这就是性能的损耗。目前只有子组件，业务逻辑也非常简单，如果是一个后台查询，这将产生严重的后果。所以这个问题必须解决。当我们点击志玲按钮时，小红对应的changeXiaohong方法不能执行，只有在点击小红按钮时才能执行。</p><h3 id="useMemo-优化性能"><a href="#useMemo-优化性能" class="headerlink" title="useMemo 优化性能"></a>useMemo 优化性能</h3><p>其实只要使用useMemo，然后给她传递第二个参数，参数匹配成功，才会执行。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildComponent</span>(<span class="params">&#123;name,children&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeXiaohong</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'她来了，她来了。小红向我们走来了'</span>)</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">',小红向我们走来了'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> actionXiaohong = useMemo(<span class="function"><span class="params">()</span>=&gt;</span>changeXiaohong(name),[name]) </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;&#123;actionXiaohong&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;&#123;children&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这时在浏览器中点击一下志玲按钮，changeXiaohong就不再执行了。也节省了性能的消耗</p><h4 id="useRef获取DOM元素和保存变量"><a href="#useRef获取DOM元素和保存变量" class="headerlink" title="useRef获取DOM元素和保存变量"></a>useRef获取DOM元素和保存变量</h4><p><code>useRef</code>在工作中虽然用的不多，但是也不能缺少。它有两个主要的作用:</p><ol><li><p>用useRef获取React JSX中的DOM元素，获取后你就可以控制DOM的任何东西了。但是一般不建议这样来作，React界面的变化可以通过状态来控制。</p></li><li><p>用useRef来保存变量，这个在工作中也很少能用到，我们有了useContext这样的保存其实意义不大，但是这是学习，也要把这个特性讲一下。</p></li></ol><h5 id="useRef获取DOM元素"><a href="#useRef获取DOM元素" class="headerlink" title="useRef获取DOM元素"></a>useRef获取DOM元素</h5><p>界面上有一个文本框，在文本框的旁边有一个按钮，当我们点击按钮时，在控制台打印出input的DOM元素，并进行复制到DOM中的value上。这一切都是通过useRef来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example8</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> onButtonClick=<span class="function"><span class="params">()</span>=&gt;</span>&#123; </span><br><span class="line">        inputEl.current.value=<span class="string">"Hello ,JSPang"</span></span><br><span class="line">        <span class="built_in">console</span>.log(inputEl) <span class="comment">//输出获取到的DOM节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &#123;<span class="comment">/*保存input的ref到inputEl */</span>&#125;</span><br><span class="line">            &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span>/&gt;</span><br><span class="line">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example8</span><br></pre></td></tr></table></figure><p>当点击按钮时，你可以看到在浏览器中的控制台完整的打印出了DOM的所有东西，并且界面上的<input/>框的value值也输出了我们写好的Hello ,JSPang。这一切说明我们可以使用useRef获取DOM元素，并且可以通过useRefu控制DOM的属性和值。</p><h5 id="useRef保存普通变量"><a href="#useRef保存普通变量" class="headerlink" title="useRef保存普通变量"></a>useRef保存普通变量</h5><p>这个操作在实际开发中用的并不多，但我们还是要讲解一下。就是useRef可以保存React中的变量。我们这里就写一个文本框，文本框用来改变text状态。又用useRef把text状态进行保存，最后打印在控制台上。写这段代码你会觉的很绕，其实显示开发中没必要这样写，用一个state状态就可以搞定，这里只是为了展示知识点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef ,useState,useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example8</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> onButtonClick=<span class="function"><span class="params">()</span>=&gt;</span>&#123; </span><br><span class="line">        inputEl.current.value=<span class="string">"Hello ,useRef"</span></span><br><span class="line">        <span class="built_in">console</span>.log(inputEl)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [text, setText] = useState(<span class="string">'jspang'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &#123;<span class="comment">/*保存input的ref到inputEl */</span>&#125;</span><br><span class="line">            &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span>/&gt;</span><br><span class="line">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;br/</span>&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;input value=&#123;text&#125; onChange=&#123;(e)=&gt;&#123;setText(e.target.value)&#125;&#125; /&gt;</span><br><span class="line">         </span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Example8</span></span><br></pre></td></tr></table></figure><p>这时想每次text发生状态改变，保存到一个变量中或者说是useRef中，这时候就可以使用useRef了。先声明一个textRef变量，他其实就是useRef函数。然后使用useEffect函数实现每次状态变化都进行变量修改，并打印。最后的全部代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef ,useState,useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example8</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> onButtonClick=<span class="function"><span class="params">()</span>=&gt;</span>&#123; </span><br><span class="line">        inputEl.current.value=<span class="string">"Hello ,useRef"</span></span><br><span class="line">        <span class="built_in">console</span>.log(inputEl)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-----------关键代码--------start</span></span><br><span class="line">    <span class="keyword">const</span> [text, setText] = useState(<span class="string">'jspang'</span>)</span><br><span class="line">    <span class="keyword">const</span> textRef = useRef()</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        textRef.current = text;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'textRef.current:'</span>, textRef.current)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//----------关键代码--------------end</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &#123;<span class="comment">/*保存input的ref到inputEl */</span>&#125;</span><br><span class="line">            &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span>/&gt;</span><br><span class="line">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;br/</span>&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;input value=&#123;text&#125; onChange=&#123;(e)=&gt;&#123;setText(e.target.value)&#125;&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Example8</span></span><br></pre></td></tr></table></figure><p>这时候就可以实现每次状态修改，同时保存到useRef中了。也就是我们说的保存变量的功能。</p><h4 id="自定义Hooks函数获取窗口大小"><a href="#自定义Hooks函数获取窗口大小" class="headerlink" title="自定义Hooks函数获取窗口大小"></a>自定义Hooks函数获取窗口大小</h4><h5 id="编写自定义函数"><a href="#编写自定义函数" class="headerlink" title="编写自定义函数"></a>编写自定义函数</h5><p>在实际开发中，为了界面更加美观。获取浏览器窗口的尺寸是一个经常使用的功能，这样经常使用的功能，就可以封装成一个自定义Hooks函数，记住一定要用use开头，这样才能区分出什么是组件，什么是自定义函数。</p><p>新建一个文件Example9.js,然后编写一个useWinSize,编写时我们会用到useState、useEffect和useCallback所以先用import进行引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState ,useEffect ,useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure><p>然后编写函数，函数中先用useState设置size状态，然后编写一个每次修改状态的方法onResize，这个方法使用useCallback，目的是为了缓存方法(useMemo是为了缓存变量)。 然后在第一次进入方法时用useEffect来注册resize监听时间。为了防止一直监听所以在方法移除时，使用return的方式移除监听。最后返回size变量就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWinSize</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ size , setSize] = useState(&#123;</span><br><span class="line">        width:<span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">        height:<span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onResize = useCallback(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setSize(&#123;</span><br><span class="line">            width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">            height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,[]) </span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>,onResize)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>,onResize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写组件并使用自定义函数"><a href="#编写组件并使用自定义函数" class="headerlink" title="编写组件并使用自定义函数"></a>编写组件并使用自定义函数</h3><p>自定义Hooks函数已经写好了，可以直接进行使用，用法和JavaScript的普通函数用起来是一样的。直接在Example9组件使用useWinSize并把结果实时展示在页面上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example9</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> size = useWinSize()</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;页面Size:&#123;size.width&#125;x&#123;size.height&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Example9</span></span><br></pre></td></tr></table></figure><p>之后就可以在浏览器中预览一下结果，可以看到当我们放大缩小浏览器窗口时，页面上的结果都会跟着进行变化。说明自定义的函数起到了作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;what-this-hooks&quot;&gt;&lt;a href=&quot;#what-this-hooks&quot; class=&quot;headerlink&quot; title=&quot;what this hooks&quot;&gt;&lt;/a&gt;what this hooks&lt;/h3&gt;&lt;p&gt; 2018年底，FaceBook的R
      
    
    </summary>
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/categories/react/"/>
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/tags/react/"/>
    
      <category term="hooks" scheme="https://jacob1811.github.io/blog/tags/hooks/"/>
    
  </entry>
  
  <entry>
    <title>react优化</title>
    <link href="https://jacob1811.github.io/blog/2019/11/18/react%E4%BC%98%E5%8C%96/"/>
    <id>https://jacob1811.github.io/blog/2019/11/18/react优化/</id>
    <published>2019-11-18T11:32:23.000Z</published>
    <updated>2019-12-27T07:04:30.336Z</updated>
    
    <content type="html"><![CDATA[<p>1、 不要在渲染函数（render）进行不必要的计算<br>比如，数组排序、数组转换、订阅事件、创建事件处理器等，宗旨是不放置太多副作用</p><p>2、 减少不必要的嵌套<br>理性选择工具，比如适当使用原生css、减少react运行时负担。大部分不必要的节点嵌套都是滥用高阶组件/renderProps导致的，只有在必要的时候才使用XXX。<br>替代方案有：props、React Hooks</p><p>3、虚拟列表<br>使用场景：</p><ul><li>无限滚动列表、 grid、表格、下拉列表、spreadsheets</li><li>无限切换的日历或轮播图</li><li>大数据量或者无限嵌套的树</li><li>聊天窗、数据流、时间轴</li><li>…</li></ul><p><a href="https://github.com/bvaughn/react-virtualized" target="_blank" rel="noopener">react-virtualized</a></p><p>antd配合推荐：（精灵使用、有新增hooks方式）</p><p><a href="https://github.com/wubostc/virtualized-table-for-antd" target="_blank" rel="noopener">virtualizedtableforantd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、 不要在渲染函数（render）进行不必要的计算&lt;br&gt;比如，数组排序、数组转换、订阅事件、创建事件处理器等，宗旨是不放置太多副作用&lt;/p&gt;
&lt;p&gt;2、 减少不必要的嵌套&lt;br&gt;理性选择工具，比如适当使用原生css、减少react运行时负担。大部分不必要的节点嵌套都是滥
      
    
    </summary>
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/categories/react/"/>
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-base</title>
    <link href="https://jacob1811.github.io/blog/2019/11/18/react-%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    <id>https://jacob1811.github.io/blog/2019/11/18/react-黑科技/</id>
    <published>2019-11-18T09:19:39.000Z</published>
    <updated>2019-12-01T02:39:12.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="react-常用小技巧"><a href="#react-常用小技巧" class="headerlink" title="react 常用小技巧"></a>react 常用小技巧</h3><ol><li>不能使用数字循环索引 作为react 列表的 key<br>渲染相邻同级元素时需要给每一个item指定相应的key作为唯一标识符，render树进行diff查找时，未发生变化的元素不重新渲染。<br>一般对象结构数据没问题，可以通过唯一 id 设置key ,但数组渲染是没有key的。如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ListRender</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      list: [<span class="number">12</span>, <span class="number">23</span>, <span class="number">43</span>, <span class="number">41</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  deleteOne = <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">list</span>: list.filter(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i !== index) &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> (</span><br><span class="line">          &lt;li  key=&#123;i&#125;&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.deleteOne(i)&#125;&gt;去除&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &#123;v&#125; &lt;input/</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在input内输入值，删除前一项，react判断 key未发生变化，按照原始结构渲染，会导致所有input错位，那就有问题了。</p><p>那怎么解决呢？<br>方法一：将数组与唯一id重新组合成对象进行操作;<br>方法二：利用 shortid 生成对应id 数组，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> shortid <span class="keyword">from</span> <span class="string">'shortid'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ListRender</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      list: [<span class="number">12</span>, <span class="number">23</span>, <span class="number">43</span>, <span class="number">41</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.dataKeys = <span class="keyword">this</span>.state.list.map(<span class="function"><span class="params">v</span> =&gt;</span> shortid.generate())</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.dataKeys) <span class="comment">// ["okFqqvP8", "-wG6MT9Oj", "3MEB9Fiuk", "pFooXW8LZ"]</span></span><br><span class="line">  &#125;</span><br><span class="line">  deleteOne = <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">list</span>: list.filter(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i !== index) &#125;)</span><br><span class="line">    <span class="keyword">this</span>.dataKeys.splice(index, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> (</span><br><span class="line">          &lt;li  key=&#123;<span class="keyword">this</span>.dataKeys[i]&#125;&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.deleteOne(i)&#125;&gt;去除&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &#123;v&#125; &lt;input/</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题完美解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;react-常用小技巧&quot;&gt;&lt;a href=&quot;#react-常用小技巧&quot; class=&quot;headerlink&quot; title=&quot;react 常用小技巧&quot;&gt;&lt;/a&gt;react 常用小技巧&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;不能使用数字循环索引 作为react 列表的 key&lt;b
      
    
    </summary>
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/categories/react/"/>
    
    
      <category term="react" scheme="https://jacob1811.github.io/blog/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>js-surprise</title>
    <link href="https://jacob1811.github.io/blog/2019/11/12/js-surprise/"/>
    <id>https://jacob1811.github.io/blog/2019/11/12/js-surprise/</id>
    <published>2019-11-12T11:55:15.000Z</published>
    <updated>2019-11-12T11:55:15.391Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python-base</title>
    <link href="https://jacob1811.github.io/blog/2019/11/10/python-base/"/>
    <id>https://jacob1811.github.io/blog/2019/11/10/python-base/</id>
    <published>2019-11-10T13:00:54.000Z</published>
    <updated>2019-11-15T11:03:09.351Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="python" scheme="https://jacob1811.github.io/blog/categories/python/"/>
    
    
      <category term="base" scheme="https://jacob1811.github.io/blog/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>不想再看的 command</title>
    <link href="https://jacob1811.github.io/blog/2019/11/01/%22%E5%8D%97%E6%9E%81%22%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>https://jacob1811.github.io/blog/2019/11/01/&quot;南极&quot;的命令/</id>
    <published>2019-11-01T02:32:02.000Z</published>
    <updated>2019-12-26T10:50:23.923Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vscode-命令"><a href="#vscode-命令" class="headerlink" title="vscode 命令"></a>vscode 命令</h3><p>运行js/py:</p><blockquote><p> control + option + N </p></blockquote><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><p>屏幕截图：</p><blockquote><p>command + shift + 3/4</p></blockquote><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><blockquote><p>tree -I ‘node_module|static’ -L 4</p></blockquote><h3 id="文件夹开权限"><a href="#文件夹开权限" class="headerlink" title="文件夹开权限"></a>文件夹开权限</h3><h3 id="删除无效git分支"><a href="#删除无效git分支" class="headerlink" title="删除无效git分支"></a>删除无效git分支</h3><blockquote><p>查看 git remote show origin</p></blockquote><blockquote><p>删除 git remote prune origin</p></blockquote><h3 id="当需要开启文件夹权限"><a href="#当需要开启文件夹权限" class="headerlink" title="当需要开启文件夹权限:"></a>当需要开启文件夹权限:</h3><blockquote><p>sudo chown -R $USER /data/db</p></blockquote><blockquote><p>sudo chown -R $USER /tmp/</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vscode-命令&quot;&gt;&lt;a href=&quot;#vscode-命令&quot; class=&quot;headerlink&quot; title=&quot;vscode 命令&quot;&gt;&lt;/a&gt;vscode 命令&lt;/h3&gt;&lt;p&gt;运行js/py:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; control + op
      
    
    </summary>
    
    
      <category term="rote" scheme="https://jacob1811.github.io/blog/categories/rote/"/>
    
    
      <category term="command" scheme="https://jacob1811.github.io/blog/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数与普通函数区别，普通函数可以通过new生成实例，箭头函数可以吗？why?</title>
    <link href="https://jacob1811.github.io/blog/2019/11/01/My-New-Post/"/>
    <id>https://jacob1811.github.io/blog/2019/11/01/My-New-Post/</id>
    <published>2019-10-31T23:19:34.000Z</published>
    <updated>2019-11-12T11:55:58.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="箭头函数与普通函数区别，普通函数可以通过new生成实例，箭头函数可以吗？why"><a href="#箭头函数与普通函数区别，普通函数可以通过new生成实例，箭头函数可以吗？why" class="headerlink" title="箭头函数与普通函数区别，普通函数可以通过new生成实例，箭头函数可以吗？why?"></a>箭头函数与普通函数区别，普通函数可以通过new生成实例，箭头函数可以吗？why?</h3><p>  区别：<br>  1.更加简洁<br>  2.箭头函数没有自己的this,它内部的this从属于函数所属上下文（call和apply也无法改变）<br>  3.箭头函数没有arguments (类数组)只能基于 …arg 获取参数（数组）<br>  4.箭头函数不能被new执行, 箭头函数没有自己的this, 没有prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const y = 7</span></span><br><span class="line"><span class="comment">//  function fn(x)&#123;</span></span><br><span class="line"><span class="comment">//   // const y = 7</span></span><br><span class="line"><span class="comment">//   return function(y)&#123;</span></span><br><span class="line"><span class="comment">//     console.log(x,y);</span></span><br><span class="line"><span class="comment">//     return x+y</span></span><br><span class="line"><span class="comment">//   &#125;(y)</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// //  console.log(fn(4))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  let fn1= x =&gt;&#123;</span></span><br><span class="line"><span class="comment">//    return (y =&gt; &#123;</span></span><br><span class="line"><span class="comment">//      console.log(111,x,y);</span></span><br><span class="line"><span class="comment">//      return x+y;</span></span><br><span class="line"><span class="comment">//     &#125;)(y)</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// let fn2 = x=&gt;y=&gt;x+y;</span></span><br><span class="line"><span class="comment">//  console.log(fn1(3));</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// * 2.箭头函数没有自己的this,它内部的this从属于函数所属上下文（call和apply也无法改变）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// let obj = &#123;</span></span><br><span class="line"><span class="comment">//   name:'jack'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// function fn1()&#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.name);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// let fn2=()=&gt;&#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.name);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// fn1();// undefined</span></span><br><span class="line"><span class="comment">// fn1.call(obj)//jack</span></span><br><span class="line"><span class="comment">// fn2() // undefined</span></span><br><span class="line"><span class="comment">// fn2.call(obj) // undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// document.body.onclick=function()&#123;</span></span><br><span class="line"><span class="comment">//   console.log(this); // this: body</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// document.body.onclick=()=&gt;&#123;</span></span><br><span class="line"><span class="comment">//   console.log(this); // this: windows </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// document.body.onclick=function()&#123;</span></span><br><span class="line"><span class="comment">//   // this: body</span></span><br><span class="line"><span class="comment">//   arr.sort(function(a,b)&#123;</span></span><br><span class="line"><span class="comment">//     // this: window 回调函数中的this一般都是window</span></span><br><span class="line"><span class="comment">//     return a-b</span></span><br><span class="line"><span class="comment">//   &#125;) </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// document.body.onclick=function()&#123;</span></span><br><span class="line"><span class="comment">//   // this: body</span></span><br><span class="line"><span class="comment">//   arr.sort((a,b)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     // this: body</span></span><br><span class="line"><span class="comment">//     return a-b</span></span><br><span class="line"><span class="comment">//   &#125;) </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// JQ forEach</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">arr,callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=arr.length;i&lt;len;i++)&#123;</span><br><span class="line">     <span class="keyword">let</span> item = arr[i]</span><br><span class="line">     index=i</span><br><span class="line">    <span class="comment">//  callback(item,index) // this: window</span></span><br><span class="line">     <span class="keyword">let</span> flag = callback.call(arr,item,index)  <span class="comment">// this: arr</span></span><br><span class="line">     <span class="comment">//接收回调函数返回的结果 如果是false结束循环</span></span><br><span class="line">     <span class="keyword">if</span> (flag === <span class="literal">false</span>)&#123;</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>);   </span><br><span class="line">     <span class="built_in">console</span>.log(item,index);</span><br><span class="line">     <span class="keyword">if</span>(index&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// * 3.箭头函数没有arguments (类数组)只能基于 ...arg 获取参数（数组）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let fn03 = ()=&gt;&#123;</span></span><br><span class="line"><span class="comment">//   console.log(arguments);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// let fn04 = (...arg)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//   console.log(arg);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// fn03(10,20,30)</span></span><br><span class="line"><span class="comment">// fn04(10,20,30)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x =<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.getX = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Fn()</span><br><span class="line">f.getX()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Fn01 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.dir(Fn01)</span><br><span class="line"><span class="comment">// Fn01.prototype.getX = function()&#123;  // Cannot set property 'getX' of undefined</span></span><br><span class="line"><span class="comment">//   console.log(this.x);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// let f01 = new Fn01() // Fn01 is not a constructor</span></span><br><span class="line"><span class="comment">// f01.getX()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;箭头函数与普通函数区别，普通函数可以通过new生成实例，箭头函数可以吗？why&quot;&gt;&lt;a href=&quot;#箭头函数与普通函数区别，普通函数可以通过new生成实例，箭头函数可以吗？why&quot; class=&quot;headerlink&quot; title=&quot;箭头函数与普通函数区别，普通
      
    
    </summary>
    
    
      <category term="com" scheme="https://jacob1811.github.io/blog/categories/com/"/>
    
    
      <category term="js" scheme="https://jacob1811.github.io/blog/tags/js/"/>
    
      <category term="css" scheme="https://jacob1811.github.io/blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-config</title>
    <link href="https://jacob1811.github.io/blog/2019/11/01/hexo-config/"/>
    <id>https://jacob1811.github.io/blog/2019/11/01/hexo-config/</id>
    <published>2019-10-31T22:09:07.025Z</published>
    <updated>2019-11-27T08:07:30.259Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h3 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官网</a></p><h3 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h3><p><a href="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/" target="_blank" rel="noopener">Hexo config blog</a></p><h3 id="炫酷配置"><a href="#炫酷配置" class="headerlink" title="炫酷配置"></a>炫酷配置</h3><p><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">Hexo炫酷配置</a></p><h3 id="next-themes"><a href="#next-themes" class="headerlink" title="next themes"></a>next themes</h3><p><a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next配置</a></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server </span><br><span class="line">// 简写</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line"></span><br><span class="line">// 简写</span><br><span class="line"></span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy  </span><br><span class="line"></span><br><span class="line">// 简写</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://jacob1811.github.io/blog/categories/Hexo/"/>
    
    
      <category term="doc" scheme="https://jacob1811.github.io/blog/tags/doc/"/>
    
  </entry>
  
</feed>
